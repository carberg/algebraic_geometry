LIB "poly.lib";
LIB "qhmoduli.lib";
LIB "cgb_mod.s";
	
proc Check_Essential(poly p, list basis) {
    poly rem;
    list q;
    int i ;

    // If p is already in the basis, then it's non-essential.
    for (i = 1; i <= size(basis); i++) {
	if (p == basis[i])
	    return 0;
    }

    // Otherwise, judge whether it's in the ideal generated by basis.
    vector v;
    for (i = 1; i <= size(basis); i++) {
        v = v + gen(i) * basis[i];
    }
    ideal G = groebner(ideal(v));
    rem = reduce(p, G);
	
    if (rem == 0) {
	// Further, test under the current specialization,
	// whether its LPP is in the ideal generated by LPP's of basis.
        vector lpp_basis;
	for (i = 1; i <= size(basis); i++) {
	    lpp_basis = lpp_basis + gen(i) * leadmonom(basis[i]);
	}
	rem = reduce(leadmonom(p), ideal(lpp_basis));
	if (rem == 0)
	    return 0;
    }

    // Otherwise, p is essential.
    return 1;
}

proc genMCCGB(ideal Polys, ideal Equ, list DisEqu, list Vars, list Paras, list Aux, RingAll, RingVar, link out) {
	ideal G;
	list modcgs;

	(G, modcgs) = cgb_mod(Polys, Equ, DisEqu, Vars, Paras, Aux, RingAll, RingVar, out);

	list mccgb;
	list mccgb_Zero;
	int i, j;
	ideal U = groebner(ideal(Auxiliary[1] - 1, Auxiliary[2]));
	ideal V = groebner(ideal(Auxiliary[1], Auxiliary[2] - 1));

	// Add the first branch.
	for (j = 1; j <= size(modcgs[0][3]); j++) {
	    mccgb_Zero[j] = reduce(modcgs[0][3][j], U);
	    mccgb[j] = mccgb_Zero[j] + reduce(modcgs[0][3][j], V);
	}


	return(mccgb);
}