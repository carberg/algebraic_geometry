LIB "poly.lib";
LIB "primdec.lib";
LIB "qhmoduli.lib";
LIB "cgb_mod.s";

proc listToVec(list l) {
    vector v;
    int i;

    for (i = 1; i <= size(l); i++) {
	v = v + gen(i) * l[i];
    }
    return (v);
}
	
proc calculateLPPList(list basis, list null_conds) {
    list res;
    vector v;
    poly f;
    int i;
    
    for (i = 1; i <= size(null_conds); i++) {
	v = v + gen(i) * null_conds[i];
    }

    ideal I = radical(ideal(v));
    ideal G = groebner(I);

    for (i = 1; i <= size(basis); i++) {
	poly p = basis[i];
	int flag = 0;
	while (!flag) {
	    if (reduce(leadcoef(p), G) == 0) {
	        p = p - lead(p);
	    } else {
	        flag = 1;
	    }
	}
	res = insert(res, leadmonom(p), size(res));
    }

    return(res);
}

// Return 1 if p is essential; otherwise, return 0.
proc Check_Essential(poly p, poly p1, list basis, list null_conds) {
    poly rem;
    list q;
    int i ;

    // If p is already in the basis, then it's non-essential.
    for (i = 1; i <= size(basis); i++) {
	if (p == basis[i]) {
	    return (0);
	}
    }

    // Otherwise, judge whether it's in the ideal generated by basis.
    vector v;
    for (i = 1; i <= size(basis); i++) {
        v = v + gen(i) * basis[i];
    }
    ideal G = groebner(ideal(v));
    rem = reduce(p, G);
	
    if (rem == 0) {
	// Further, test under the current specialization,
	// whether its LPP is in the ideal generated by LPP's of basis.
        vector lpp_basis = listToVec(calculateLPPList(basis, null_conds));
	ideal H = groebner(ideal(lpp_basis));
	if (reduce(leadmonom(p1), H) == 0) {
	    return (0);
	}
    }

    // Otherwise, p is essential.
    return (1);
}

proc genMCCGB(ideal Polys, ideal Equ, list DisEqu, list Vars, list Paras, list Aux, RingAll, RingVar, link out) {
	ideal G;
	list modcgs;

	(G, modcgs) = cgb_mod(Polys, Equ, DisEqu, Vars, Paras, Aux, RingAll, RingVar, out);

	list mccgb;
	int i, j;
	ideal U = groebner(ideal(Auxiliary[1] - 1, Auxiliary[2]));
	ideal V = groebner(ideal(Auxiliary[1], Auxiliary[2] - 1));

	// Add the first branch.
	for (j = 1; j <= size(modcgs[1][3]); j++) {
	    mccgb[j] = reduce(modcgs[1][3][j], U) + reduce(modcgs[1][3][j], V);
	}

	if (size(modcgs) > 1) {
	    // Consider each branch.
	    for (i = 2; i <= size(modcgs); i++) {
		list null_conds;

	        // If Groebner Basis of the branch is empty, then pass.
	        if (size(modcgs[i][3]) != 0) {
		    // Build the list of null conditions.
	            for (j = 1; j <= size(modcgs[i][1]); j++) {
			null_conds = insert(null_conds, modcgs[i][1][j], size(null_conds));
	            }

	            // For each polynomial in the Groebner Basis.
	            for (j = 1; j <= size(modcgs[i][3]); j++) {
			poly p0 = reduce(modcgs[i][3][j], U);
	                poly p1 = reduce(modcgs[i][3][j], V);
	                poly p = p0 + p1;

	                if (Check_Essential(p, p1, mccgb, null_conds) == 1) {
			    // p is essential, add to mccgb.
	                    mccgb = insert(mccgb, p, size(mccgb));
	                }
	            } 
	        }

	    }
	}


	return(mccgb);
}