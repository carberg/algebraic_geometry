LIB "mccgb.lib";

proc check_correctness(list mccgb, ideal F, list modcgs, link out)
{
  // basering is @R.
  set_global_rings_mccgb();

  fprintf(out, newline + "=======================");
  fprintf(out, "Now check whether MCCGB is comprehensive and minimal:");
  fprintf(out, "--------------");

  fprintf(out, "First check the comprehensiveness of MCCGB:" + newline);

  if (check_comprehensive(mccgb, F, modcgs, out)) {
    // mccgb is comprehensive, then check the minimality.
    fprintf(out, newline + "MCCGB is comprehensive.");
    fprintf(out, newline + "------------------------");
    fprintf(out, "Second, check the minimality of MCCGB:");
    if (check_minimal(mccgb, F, modcgs, out)) {
      // mccgb is also minimal.
      fprintf(out, newline + "MCCGB is minimal.");
      return ("", 1);
    } else {
      // mccgb is not minimal.
      fprintf(out, newline + "MCCGB is not minimal.");
      return ("it is not minimal", 0);
    }
  } else {
    // mccgb is not comprehensive.
    fprintf(out, newline + "MCCGB is not comprehensive.");
    return ("it is not comprehensive", 0);
  }
}

proc check_comprehensive(list basis, ideal F, list modcgs, link out) {
  // basering is @R.

  int i;
  int num_branches = size(modcgs);

  // For each branch ((E_i, N_i), G_i).
  for (i = 1; i <= num_branches; i++) {
    fprintf(out, newline + "  Branch %s: ({%s}, {%s}):", string(i), string(modcgs[i][1]), string(modcgs[i][2]));

    // Get list of null conditions.
    int j;
    list null_conds;
    
    if (size(modcgs[i][1]) == 0) {
      null_conds = list();
    } else {
      for (j = 1; j <= size(modcgs[i][1]); j++) {
	null_conds = insert(null_conds, modcgs[i][1][j], size(null_conds));
      }
    }

    // Consider G_i.
    if (size(modcgs[i][3]) != 0) {
      // G_i is not empty.

      // Get sigma(F), sigma(mccgb), and sigma(G_i).
      def sigma_F = get_sigma_basis(basis, null_conds, modcgs[i][2], 0);
      def sigma_basis = get_sigma_basis(basis, null_conds, modcgs[i][2], 0);
      def sigma_g = get_nonzero_part(modcgs[i][3]);

      fprintf(out, "    sigma(F) = {%s};", string(sigma_F));
      fprintf(out, "    sigma(G_%s) = {%s};", string(i), string(sigma_g));
      fprintf(out, "    sigma(basis) = {%s}.", string(sigma_basis));

      // Check whether sigma(basis) generates sigma(F).
      if (size(sigma_F) == 0) {
	// sigma(F) is empty.
	if (sigma(basis) > 0) {
	  fprintf(out, "  sigma(basis) is not GB for Branch %s.", string(i));
	  return (0);
	}
      } else {
	// sigma(F) is not empty.
	ideal I_sigma_basis = ideal(listToVec(sigma_basis));
	for (j = 1; j <= size(sigma_F); j++) {
	  poly rem = reduce(sigma_F[j], I_sigma_basis);
	  if (rem != 0) {
	    // The remainder is not 0, then switch to Q[X, A].
	    def coef_list = get_coef_list(rem);
	    setring(@RP);
	    def coef_list = imap(@R, coef_list);
	    def modcgs = imap(@R, modcgs);
	    def E = modcgs[i][1];

	    // Check whether the remainder can be reduced to 0 under radical of E.
	    if (!check_coef_list_null(coef_list, E)) {
	      setring(@R);
	      fprintf(out, "  sigma(basis) is not GB of branch %s.", string(i));
	      return (0);
	    } else {
	      setring(@R);
	    } // End if.
	  } // End if.
	} // End for j.

	// Check whether <LPP_X(sigma_basis)> == <LPP_X(sigma_g)>.
	if (size(sigma_g) == 0) {
	  if (size(sigma_basis) > 0) {
	    fprintf(out, "  sigma(basis) is not GB of branch %s.", string(i));
	    return (0);
	  }
	} else {
	  if (size(sigma_basis) == 0) {
	    fprintf(out, "  sigma(basis) is not GB of branch %s.", string(i));
	    return (0);
	  } else {
	    setring(@RP);
	    def sigma_basis = imap(@R, sigma_basis);
	    def sigma_g = imap(@R, sigma_g);
	    def modcgs = imap(@R, modcgs);
	    
	    // Calculate the LPP_X of sigma(basis) and sigma(G_i).
	    list lpp_sigma_basis = calculateLPPList(sigma_basis, modcgs[i][1], modcgs[i][2]);
	    list lpp_sigma_g = calculateLPPList(sigma_g, modcgs[i][1], modcgs[i][2]);

	    ideal I1 = groebner(ideal(listToVec(lpp_sigma_basis)));
	    ideal I2 = groebner(ideal(listToVec(lpp_sigma_g)));
	    if (!ideal_equal(I1, I2)) {
	      fprintf(out, "  sigma(basis) is not GB of branch %s.", string(i));
	      setring(@R);
	      return (0);
	    } // End if.
	    setring(@R);
	  } // End if.
	} // End if.
      } // End if.
    } else {
      // G_i is empty.
      fprintf(out, "    G_%s is empty;", string(i));

      // Get sigma_basis.
      def sigma_basis = get_sigma_basis(basis, null_conds, modcgs[i][2], 0);
      fprintf(out, "    sigma(basis) = {%s}.", string(sigma_basis));

      if (size(sigma_basis) > 0) {
	fprintf(out, "  sigma(basis) is not GB of branch %s.", string(i));
      }
    } // End if.
    fprintf(out, "  sigma(basis) is GB for branch %s.", string(i));
  } // End for i.

  return (1);
}

proc ideal_equal(ideal I, ideal J) {
  // basering is Q[X, A].
  int i;
  for (i = 1; i <= size(I); i++) {
    if (reduce(I[i], J) != 0) {
      return (0);
    }
  }

  for (i = 1; i <= size(J); i++) {
    if (reduce(J[i], I) != 0) {
      return (0);
    }
  }

  return (1);
}
