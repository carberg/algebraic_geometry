LIB "mccgb.lib";

proc check_correctness(list mccgb, ideal F, list modcgs, link out)
{
  // basering is @R.
  set_global_rings_mccgb();

  fprintf(out, newline + "=======================");
  fprintf(out, "Now check whether MCCGB is comprehensive and minimal:");
  fprintf(out, "--------------");

  fprintf(out, "First check the comprehensiveness of MCCGB:" + newline);

  if (check_comprehensive(mccgb, F, modcgs, out)) {
    // mccgb is comprehensive, then check the minimality.
    fprintf(out, newline + "MCCGB is comprehensive.");
    fprintf(out, newline + "------------------------");
    fprintf(out, "Second, check the minimality of MCCGB:");
    if (check_minimal(mccgb, F, modcgs, out)) {
      // mccgb is also minimal.
      fprintf(out, newline + "MCCGB is minimal.");
      return ("", 1);
    } else {
      // mccgb is not minimal.
      fprintf(out, newline + "MCCGB is not minimal.");
      return ("it is not minimal", 0);
    }
  } else {
    // mccgb is not comprehensive.
    fprintf(out, newline + "MCCGB is not comprehensive.");
    return ("it is not comprehensive", 0);
  }
}

proc check_comprehensive(list basis, list modcgs, link out) {
  // basering is @R.
  int i;
  
  // For each branch.
  for (i = 1; i <= size(modcgs); i++) {
    list sigma_basis = get_sigma_basis(basis, modcgs[i][1], modcgs[i][2], 0);
    list sigma_g = get_nonzero_part(modcgs[i][3]);

    // The case when G_i is empty.
    if (size(sigma_g) == 0) {
      if (size(sigma_basis) > 0) {
	return (0);
      }
    }

    // Otherwise.
    // Calculate the LPP list of Basis_M.
    list lpp_list_basis;
    int j;
    for (j = 1; j <= size(basis); j++) {
      poly curP = specialize(basis[j], modcgs[i][1], modcgs[i][2]);
      if (curP != 0) {
	lpp_list_basis = insert(lpp_list_basis, lpp_X(curP), size(lpp_list_basis));
      }
    }

    // For each poly in G \ G_0.
    list G_nonzero = get_G_nonzero(modcgs[i][3]);
    for (j = 1; j <= size(G_nonzero); j++) {
      if (divides(lpp_X(G_nonzero[j]), lpp_list_basis) == 0) {
	return (0);
      }
    }

  } // End for each branch.

  return (1);
}

proc get_G_nonzero(list l) {
  if (size(l) == 0) {
    return (list());
  } else {
    int i;
    list G_nonzero_list;
    for (i = 1; i <= size(l); i++) {
      if (l[i][1] != 0) {
	G_nonzero_list = insert(G_nonzero_list, l[i][1] + l[i][2], size(G_nonzero_list));
      }
    }
    return (G_nonzero_list);
  }
}

proc divides(poly p, list basis) {
  if (size(basis) == 0) {
    return (0);
  } else {
    int i;
    for (i = 1; i <= size(basis); i++) {
      if (p / basis[i] != 0) {
	return (1);
      }
    }

    return (0);
  }
}

proc specialize(poly p, ideal E, list N) {
  ideal GE = radical(E);
  ideal G = groebner(GE);
  poly p1;

  while (p != 0) {
    poly lcxP = leadcoef_X(p);
    if (reduce(lcxP, G) != 0) {
      p1 = p1 + lm_X(p);
    }
    p = p - lm_X(p);
  }

  return (p1);
}
