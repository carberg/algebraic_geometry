LIB "mcgb.lib";

/*
Global Structures:

STLIST -- map of specialized tuples.
type: list
structures:
1 -- faithful polynomial f
2 -- list of specialized tuples of f:
    1 -- specialized form
    (2, 3) -- segment of this form


CPairs -- list of critical pairs
type: list
each element:
1 -- ideal of f and its specialized form:
    (1, 2) -- (f, f_nz)
2 -- ideal of g and its specialized form:
    (1, 2) -- (g, g_nz)
(3, 4) -- the intersected segment (E, N)

NFLIST -- map of normal forms under segments.
type: list
structures:
1 -- faithful polynomial f
2 -- has it been tried to specialize before?
3 -- list of normal forms of f under segments.
    (1, 2) -- the intersected segment (E, N)
    (3, 4) -- normal form (rem, m)

SBLIST -- map of specialized bases.
type: list
structures:
(1, 2) -- segment (E, N)
3 -- ideal of specialized basis under (E, N)
 */

proc isRedundant(poly f, ideal G) {
  if (size(G) <= 1) {
    return (0);
  }

  int idx = searchNFlist(f);
  list st;
  
  if (idx == -1) {
    ERROR("out of index!");
  }

  int is_checked = NFLIST[idx][2];

  if (is_checked) {
    // We can directly use NFLIST[idx][3].
    int i;
    list nf = NFLIST[idx][3];
    poly rem, m, E, N;
    for (i = 1; i <= size(nf); i++) {
      if (nf[i][3] != 0) {
	E = nf[i][1];
	N = nf[i][2];
	rem = nf[i][3];

	ideal G_nz = simplifyBasis(G, E, N);
	(rem, m) = reduceUnderSegment(rem, G_nz, E, N);
	if (rem != 0 && rem != nf[i][3]) {
	  updateNFLIST()
	}
      }
    }
  } else {
    // Compute, and store as NFLIST[idx][3].
  }
  
}

proc searchNFlist(poly f) {
  f = monic(f);
  if (size(NFLIST) == 0) {
    return (-1);
  }

  int i;
  for (i = 1; i <= size(NFLIST); i++) {
    if (f == NFLIST[i][1]) {
      return (i);
    }
  }

  return (-1);
}

proc deletePolyFromIdeal(poly f, ideal G) {

}

proc deleteSTuples(poly f) {

}

proc buildCriticalPairs() {

}

proc searchSTuples(poly f) {
  f = monic(f);
  int i;
  if (size(STLIST) == 0) {
    return (-1);
  }

  for (i = 1; i <= size(STLIST); i++) {
    if (f == STLIST[i][1]) {
      return (i);
    }
  }

  return (-1);
}

proc selectCPair() {

}

proc getFaithSPolyFromCPair(list cp) {

}

proc simplifyBasisFaith(ideal G, ideal E, list N) {

}

proc reduceFaithSegment(poly h, poly h_nz, ideal G, ideal G_nz, ideal E, list N) {

}

proc reduceUnderSegment(poly h, ideal G, ideal E, list N) {

}

proc insertCPairs(ideal G, poly f) {

}

proc insertDescSet(G, poly f) {

}

proc insertSTuples(poly f, ideal E, list N) {
  list st;
  poly koeff;
  
  while (f != 0) {
    koeff = leadcoef_U(f);
    if (Check_Consistence_CGB(E, N + list(koeff))) {
      st = insert(st, list(f, E, N + list(koeff)), size(st));
    } else {
      break;
    }
    E = E + ideal(koeff);
    f = monic(f - lm_X(f));
  }

  STLIST = insert(STLIST, list(f, st), size(STLIST));
}

proc updateNFLIST(poly f, ideal G) {

}

proc mcgbGenerate(ideal E, list N, ideal F) {
  set_global_rings();
  set_global_rings_mcgb();
  set_global_objects();

  if (size(F) <= 1) {
    return (F);
  }

  if (size(N) == 0) {
    N = 1;
  }

  option(redSB);

  def G = F;
  G = sortSetDesc(G);

  def BR = basering;
  int ring_flag = 0;
  if (nameof(BR) != "@RP") {
    setring @RP;
    def E = imap(BR, E);
    def N = imap(BR, N);
    def G = imap(BR, G);
    ring_flag = 1;
  }
  
  // Construct specialized tuples of each poly in G.
  int i, j;

  list STLIST;
  list STuples;
  for (i = 1; i <= size(G); i++) {
    insertSTuples(G[i], E, N);
  }
  
  export(STLIST);

  // Remove redundant poly.
  ideal M = G;
  for (i = 1; i <= size(G); i++) {
    if (isRedundant(G[i], M)) {
      M = deletePolyFromIdeal(M, G[i]);
      deleleteSTuples(G[i]);
    }
  }
  G = M;

  // Initialize the list of critical pairs to be checked.
  list CPairs = buildCriticalPairs();
  export(CPairs);

  // Initialize the list of normal forms.
  list NFLIST;
  for (i = 1; i <= size(G); i++) {
    STuples = searchSTuples(G[i]);
    // To be finished.
  }

  export(NFLIST);

  list cp;
  while (size(CPairs) > 0) {
    cp = selectCPair();

    poly sp, sp_nz;
    ideal E_cur = cp[3];
    list N_cur = cp[4];
    (sp, sp_nz) = getFaithSPolyFromCPair(cp);

    ideal basis, basis_nz;
    (basis, basis_nz) = simplifyBasisFaith(G, E_cur, N_cur);
    
    poly nf, nf_nz, teiler;
    (nf, nf_nz, teiler) = reduceFaithSegment(nf, nf_nz, basis, basis_nz, E_cur, N_cur);

    if (nf != 0) {
      // Remove redundant poly.
      ideal M = G;
      for (i = 1; i <= size(G); i++) {
	if (isRedundant(G[i], insertPolyToIdeal(M, nf))) {
	  M = deletePolyFromIdeal(M, G[i]);
	  STLIST = deleteSTuples(STLIST, G[i]);
	}
      }
      G = M;

      // Add new CPairs and poly.
      insertCPairs(M, nf);
      G = insertDescSet(G, nf);
      STLIST = insertSTuples(nf, E_cur, N_cur);
      updateNFLIST(nf, G);
    }
  }

  def MCGB = G;
  
  if (ring_flag) {
    setring BR;
    def MCGB = imap(@RP, MCGB);
  }
  
  return (MCGB);
}
