LIB "poly.lib";
LIB "primdec.lib";
LIB "qhmoduli.lib";
LIB "teachstd.lib";

LIB "../CGB/cgb_mod.s";

proc set_global_rings() {
  def BR = basering;
  def @R = basering;

  def Rx = ringlist(BR);
  def @P = ring(Rx[1]);

  Rx[1] = 0;
  def D = ring(Rx);
  def @RP = D + @P;

  exportto(Top, @R);
  exportto(Top, @P);
  exportto(Top, @RP);
  setring(BR);
	
}
	
proc listToVec(list l) {
    vector v;
    int i;

    for (i = 1; i <= size(l); i++) {
	v = v + gen(i) * l[i];
    }
    return (v);
}

proc leadcoef_X(poly P) {
    def BR = basering;
    setring(@R);

    def P = imap(BR, P);
    poly c = leadcoef(P);
    setring(BR);
    def c = imap(@R, c);
    return (c);
}

proc lpp_X(poly P) {
    def BR = basering;

    setring(@R);
    def P = imap(BR, P);
    def m = leadmonom(P);

    setring(BR);
    def m = imap(@R, m);
    return (m);
}

proc lm_X(poly P) {
    def BR = basering;
    setring(@R);
    def P = imap(BR, P);

    def T = lead(P);
    setring(BR);
    def T = imap(@R, T);
    return (T);
}
	
proc calculateLPPList(list basis, list null_conds) {
    printf("Now Compute LPP of basis under specialization:");

    def BR = basering;
    setring(@R);
    def basis = imap(BR, basis);
    def null_conds = imap(BR, null_conds);

    int i;

    setring(@RP);
    def null_conds = imap(@R, null_conds);
    vector v;
    list res;
	
    for (i = 1; i <= size(null_conds); i++) {
	v = v + gen(i) * null_conds[i];
    }

    ideal I = radical(ideal(v));
    ideal G = groebner(I);
    printf("RADICAL: %s", string(I));

    for (i = 1; i <= size(basis); i++) {
	poly p = basis[i];
	while (p != 0) {
	    if (reduce(leadcoef_X(p), G) == 0) {
	        p = p - lm_X(p);
	    } else {
	        break;
	    }
	}
	printf("Sigma(g[%s]) is %s.", string(i), string(p));
	res = insert(res, leadmonom(p), size(res));
    }

    // Switch back to R[A][X].
    setring(@R);
    def res = imap(@RP, res);
    for (i = 1; i <= size(res); i++) {
        res[i] = leadmonom(res[i]);
    }
	
    setring(BR);
    def res = imap(@R, res);
    printf("The LPP of MCCGB is: %s", string(res));
    return(res);
}

// Return 1 if p is essential; otherwise, return 0.
proc Check_Essential(poly p, poly p1, list basis, list null_conds) {
    poly rem;
    list q;
    int i ;

    printf(newline+"Checking Essential:");
	
    // If p is already in the basis, then it's non-essential.
    for (i = 1; i <= size(basis); i++) {
	if (p == basis[i]) {
	    printf("%s is in MCCGB.", string(p));
	    return (0);
	}
    }
    printf("%s is not in MCCGB.", string(p));

    // Otherwise, judge whether it's in the ideal generated by basis.
    vector v;
    for (i = 1; i <= size(basis); i++) {
        v = v + gen(i) * basis[i];
    }
    ideal G = groebner(ideal(v));
    rem = reduce(p, G);
	
    if (rem == 0) {
        printf("%s is in the ideal generated by %s.", string(p), string(basis));
	
	// Further, test under the current specialization,
	// whether its LPP is in the ideal generated by LPP's of basis.
        vector lpp_basis = listToVec(calculateLPPList(basis, null_conds));
	ideal H = groebner(ideal(lpp_basis));
	printf("LPP(P) is %s.", lpp_X(p1));
	if (reduce(lpp_X(p1), H) == 0) {
	    printf("%s is in the ideal generated by %s.", string(leadmonom(p1)), string(ideal(lpp_basis))) ;
	    return (0);
	}
    }

    // Otherwise, p is essential.
    return (1);
}

proc genMCCGB(Polys, Equ, DisEqu, vars, params, aux, RingVar, out) {
	set_global_rings();

	// This part needs to be removed when using cgb_mod_new.
	def BR = basering;
	setring(@RP);
	def Polys = imap(RingVar, Polys);
	def Equ = imap(RingVar, Equ);
	def DisEqu = list()	    ;
	def vars = imap(RingVar, vars);
	def params = imap(RingVar, params);
	def aux = imap(BR, aux);
	def RingAll = @RP;
	// End Comment.

        ideal G;
	list modcgs;
	
	(G, modcgs) = cgb_mod(Polys, Equ, DisEqu, vars, params, aux, RingAll, RingVar, out);

	list mccgb;
	int i, j;
	ideal U = groebner(ideal(Auxiliary[1] - 1, Auxiliary[2]));
	ideal V = groebner(ideal(Auxiliary[1], Auxiliary[2] - 1));

	// Add the first branch.
	for (j = 1; j <= size(modcgs[1][3]); j++) {
	    mccgb[j] = reduce(modcgs[1][3][j], U) + reduce(modcgs[1][3][j], V);
	}
	printf("After adding the first branch:");
	show(mccgb);

	if (size(modcgs) > 1) {
	    // Consider each branch.
	    for (i = 2; i <= size(modcgs); i++) {
		list null_conds;
	        printf(newline+"Coming to Branch %s:", string(i));

	        // If Groebner Basis of the branch is empty, then pass.
	        if (size(modcgs[i][3]) != 0) {
		    // Build the list of null conditions.
	            for (j = 1; j <= size(modcgs[i][1]); j++) {
			null_conds = insert(null_conds, modcgs[i][1][j], size(null_conds));
	            }
	            printf("The null conditions are:");
	            show(null_conds);

	            // For each polynomial in the Groebner Basis.
	            for (j = 1; j <= size(modcgs[i][3]); j++) {
			poly p1 = reduce(modcgs[i][3][j], U);
	                poly p0 = reduce(modcgs[i][3][j], V);
	                printf("P = [ %s , %s ].", string(p1), string(p0))  ;
	                poly p = p1 + p0;

	                printf(newline+"Currently consider polynomial %s.", string(p));

	                if (Check_Essential(p, p1, mccgb, null_conds) == 1) {
			    // p is essential, add to mccgb.
	                    printf("%s is essential.", string(p));
	                    mccgb = insert(mccgb, p, size(mccgb));
	                }
	            } 
	        }

	    }
	}

	// Switch back to @R.
	setring(BR);
	def mccgb = imap(@RP, mccgb);
	def G = imap(@RP, G);
	def modcgs = imap(@RP, modcgs);

	return(mccgb, G, modcgs);
}

proc showMCCGB(list mccgb, link out) {
    int i;

    fprintf(out, "The MCCGB is:" + newline );
    if (size(mccgb) == 0) {
        fprintf(out, "{  }." + newline);
    } else {
	for (i = 1; i < size(mccgb); i++) {
	    fprintf(out, "%s,", mccgb[i]);
	}
	fprintf(out, "%s." + newline, mccgb[size(mccgb)]);
    }
}

proc get_nonzero_part(list l) {
    ideal U = groebner(ideal(Auxiliary[1] - 1, Auxiliary[2]));
    int i;
    list res_list;

    for (i = 1; i <= size(l); i++) {
	res_list[i] = reduce(l[i], U);
    }

    return (res_list);
}

proc get_sigma_basis(list basis, list null_conds) {
  if (size(null_conds) == 0) {
    return (basis);
  }

  // Switch to Q[X, A].
  int i;
  def BR = basering;
  setring(@RP);
  def basis = imap(BR, basis);
  def null_conds = imap(BR, null_conds);
  vector v;
  list sigma_basis;

  for (i = 1; i <= size(null_conds); i++) {
    v = v + gen(i) * null_conds[i];
  }

  ideal E = radical(ideal(v));
  ideal GE = groebner(E);

  for (i = 1; i <= size(basis); i++) {
    poly p = basis[i];
    poly p1 = 0;
    while (p != 0) {
      if (reduce(leadcoef_X(p), GE) != 0) {
	p1 = p1 + lm_X(p);
      }
      p = p - lm_X(p);
    } // End of while.
    if (p1 != 0) {
      sigma_basis = insert(sigma_basis, p1, size(sigma_basis));
    }
  } // End of for.

  // The case that sigma(basis) is empty should be processed specially.
  int empty_flag = size(sigma_basis);

  // Switch back to Q[A][X].
  setring(BR);
  if (empty_flag == 0) {
    def sigma_basis = 0;
  } else {
    def sigma_basis = imap(@RP, sigma_basis);
  }

  return (sigma_basis);
}

proc check_ideal_equality(list g1, list g2) 
"USAGE:    Check whether ideals <g1> and <g2> are equivalent.
RETURN:    1 if they are equivalent; 0 otherwise."
{
  // Basering is Q[A][X].
  def I = groebner(ideal(listToVec(g1)));
  def J = groebner(ideal(listToVec(g2)));
  int i;
  int flag = 1;

  for (i = 1; i <= size(g1); i++) {
    if (reduce(g1[i], J) != 0) {
      flag = 0;
      break;
    }
  }

  if (flag != 0) {
    for (i = 1; i <= size(g2); i++) {
      if (reduce(g2[i], I) != 0) {
	flag = 0;
	break;
      }
    }
  }

  return (flag);
}

proc check_comprehensive(basis, modcgs) 
"USAGE:    Check whether mccgb is a comprehensive Groebner basis for the given CGS modcgs.
RETURN:    1 if mccgb is CGB; 0 otherwise."
{
  printf(newline + "Now Checking the Comprehensivibility of %s:", string(basis));
  int i;
  int flag = 0;
  int num_branches = size(modcgs);

  // For each branch ((E_i, N_i), G_i).
  for (i = 1; i <= num_branches; i++) {
    printf("  Branch %s: ({%s}, {%s}):", string(i), string(modcgs[i][1]), string(modcgs[i][2]));
    if (size(modcgs[i][3]) != 0) {
      // G_i is not empty.
      // Get sigma(G_i).
      def sigma_g = get_nonzero_part(modcgs[i][3]);
      printf("    sigma(G_%s) = {%s}", string(i), string(sigma_g));

      // Get sigma(basis).
      if (size(modcgs[i][1]) == 0) {
	// The null condition set is empty.
	def sigma_basis = basis;
      } else {
	// The null condition set is not empty.
	int j;
	list null_conds;
	for (j = 1; j <= size(modcgs[i][1]); j++) {
	  null_conds = insert(null_conds, modcgs[i][1][j], size(null_conds));
	}
	def sigma_basis = get_sigma_basis(basis, null_conds);
      }
      printf("    sigma(basis) = {%s}", string(sigma_basis));
    
      // Check whether sigma(basis) is a Groebner basis.
      if (check_groebner(sigma_basis)) {
	// Check whether <sigma(basis)> = <sigma(g)>.
	if (check_ideal_equality(sigma_g, sigma_basis)) {
	  flag = flag + 1;
	  printf("  sigma(basis) is GB for Branch %s.", string(i));
	} else {
	  printf("  sigma(basis) is not GB for Branch %s.", string(i));
	  return (0);
	}
      } else {
	printf("  sigma(basis) is not even a GB under the specialization.", string(i));
	return (0);
      }
  
    } else {
      // G_i is empty.
      printf("    G_%s is empty.", string(i));
      printf("  sigma(basis) is GB for Branch %s.", string(i));

    } // End of if.
  } // End of for.

  return (1);
} // End of proc.

proc gen_sub_list(list l) 
"USAGE:    Generate all the largest proper subsets of l.
RETURN:    A list of lists."
{
  int i, j;
  list res_list;
  
  if (size(l) != 0 && size(l) != 1) {
    for (i = 1; i <= size(l); i++) {
      list k;
      for (j = 1; j <= size(l); j++) {
	if (i != j) {
	  k = insert(k, l[j], size(k));
	}
      }
      res_list[i] = k;
    }
  } // End of if.

  return (res_list);
}

proc check_groebner(list basis) {
  // Basering is Q[A][X].
  if (size(basis) <= 1) {
    return(1);
  }

  int i, j;
  ideal I = ideal(listToVec(basis));
  for (i = 1; i <= size(basis); i++) {
    for (j = 1; j <= size(basis); j++) {
      if (i != j) {
	poly f = spoly(basis[i], basis[j]);
	if (reduce(f, I) != 0) {
	  return (0);
	}
      }
    }
  }

  return (1);
}

proc check_minimality(list cgb, list modcgs) 
"USAGE:    Check whether cgb is minimal, given that it is already comprehensive.
RETURN:    1 if cgb is minimal; 0 otherwise."
{
  printf(newline + "Now Checking the Minimality:");
  if (size(cgb) <= 1) {
    printf("Basis is minimal!");
    return (1);
  }

  list sub_sets = gen_sub_list(cgb);
  int i;

  // For each largest proper subset of cgb.
  for (i = 1; i <= size(sub_sets); i++) {
    printf(newline + "%s.  Now Check the subset {%s}:", string(i), string(sub_sets[i]));
    if (check_comprehensive(sub_sets[i], modcgs)) {
	// If the current proper subset of cgb is also a CGB,
        //  then cgb is not minimal.
	printf("The subset {%s} is also CGB.", string(sub_sets[i]));
	return (0);
    }
  }

  return (1);
}

proc check_validity(list mccgb, list modcgs) 
"USAGE:    Check whether mccgb is minimal and comprehensive for the given CGS modcgs.
RETURN:    A string denoting why mccgb is not MCCGB;
           An integer flag denoting whether mccgb is valid (return (1)) or not (return (0)).
EXAMPLE:   (err_msg, flag) = check_validity(mccgb, Modcgs);"
{

  if (check_comprehensive(mccgb, modcgs)) {
    // mccgb is comprehensive, then check the minimality.
    printf("Basis is comprehensive.");
    if (check_minimality(mccgb, modcgs)) {
      // mccgb is also minimal.
      return ("", 1);

    } else {
      // mccgb is not minimal.
      return ("it is not minimal", 0);
    }

  } else {
    // mccgb is not comprehensive.
    return ("it is not comprehensive", 0);
  }

}
