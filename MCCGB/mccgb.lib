LIB "poly.lib";
LIB "primdec.lib";
LIB "qhmoduli.lib";
LIB "teachstd.lib";

LIB "../CGB/cgb_mod.lib";

proc set_global_rings_mccgb() {
  def BR = basering;
  def @R = basering;

  def Rx = ringlist(BR);
  def @P = ring(Rx[1]);

  Rx[1] = 0;
  def D = ring(Rx);
  def @RP = D + @P;
  show(@RP);

  exportto(Top, @R);
  exportto(Top, @P);
  exportto(Top, @RP);
  setring(BR);
	
}
	
proc listToVec(list l) {
    vector v;
    int i;

    if (size(l) == 0) {
      return (vector(0));
    }

    for (i = 1; i <= size(l); i++) {
	v = v + gen(i) * l[i];
    }
    return (v);
}

proc vecToList(vector v) {
  list l;
  int i;
  
  if (size(v) == 0) {
    return list();
  }

  for (i = 1; i <= size(v); i++) {
    l[i] = v[i];
  }

  return (l);
}

proc leadcoef_X(poly P) {
  int flag = 0;
  if (nameof(basering) != "@R") {
    def BR = basering;
    setring(@R);
    flag = 1;
    def P = imap(BR, P);
  }

  poly c = leadcoef(P);

  if (flag) {
    setring(BR);
    def c = imap(@R, c);
  }

  return (c);
}

proc lpp_X(poly P) {
  int flag = 0;

    if (nameof(basering) != "@R") {
      def BR = basering;
      setring(@R);
      flag = 1;
      def P = imap(BR, P);
    }

    def m = leadmonom(P);

    if (flag) {
      setring(BR);
      def m = imap(@R, m);
    }

    return (m);
}

proc lm_X(poly P) {
  int flag = 0;
  if (nameof(basering) != "@R") {
    def BR = basering;
    setring(@R);
    flag = 1;
    def P = imap(BR, P);
  }

  def T = lead(P);

  if (flag) {
    setring(BR);
    def T = imap(@R, T);
  }

  return (T);
}

proc calculateLPPList(list basis) {
  if (size(basis) == 0) {
    return (list(0));
  }

  int i;
  list lpplist;
  for (i = 1; i <= size(basis); i++) {
    lpplist = insert(lpplist, lpp_X(basis[i]), size(lpplist));
  }

  return (lpplist);
}

proc calculateSigmaLPPList(list basis, ideal E, list N) {
  // Basering is @RP.
  printf("Now Compute LPP of basis under specialization:");
  
  if (size(basis) == 0) {
    return (list(0));
  }

  int i;

  ideal I = radical(E);
  ideal GE = groebner(I);

  poly nonnull_cond = 1;
  if (size(N) != 0) {
    for (i = 1; i <= size(N); i++) {
      nonnull_cond = nonnull_cond * N[i];
    }
  }
  list lpp_list = get_sigma_basis_with_single_nonnull(basis, E, nonnull_cond, 0);

  if (size(lpp_list) != 0) {
    for (i = 1; i <= size(lpp_list); i++) {
      lpp_list[i] = lpp_X(lpp_list[i]);
    }
  }

  return (lpp_list);
}

// Return 1 if p is essential; otherwise, return 0.
proc Check_Essential(poly p, poly p1, list basis, ideal E, list N, link out) {
    poly rem;
    list q;
    int i ;

    fprintf(out, newline+"Checking Essential:");
	
    // If p is already in the basis, then it's non-essential.
    for (i = 1; i <= size(basis); i++) {
	if (p == basis[i]) {
	  fprintf(out, "%s is in MCCGB.", string(p));
	    return (0);
	}
    }
    fprintf(out, "%s is not in MCCGB.", string(p));

    // Otherwise, judge whether it's in the ideal generated by basis.
    vector v;
    for (i = 1; i <= size(basis); i++) {
        v = v + gen(i) * basis[i];
    }
    ideal G = groebner(ideal(v));
    rem = reduce(p, G);
	
    if (rem == 0) {
      fprintf(out, "%s is in the ideal generated by MCCGB.", string(p));
	
	// Further, test under the current specialization,
	// whether its LPP is in the ideal generated by LPP's of basis.
      vector lpp_basis = listToVec(calculateSigmaLPPList(basis, E, N));
	ideal H = groebner(ideal(lpp_basis));
	fprintf(out, "LPP(P) is %s;", lpp_X(p1));
	fprintf(out, "LPP(MCCGB) is {%s}.", string(ideal(lpp_basis)));
	if (reduce(lpp_X(p1), H) == 0) {
	  fprintf(out, "%s is in the ideal generated by LPP(MCCGB).", string(lpp_X(p1))) ;
	    return (0);
	} else {
	  fprintf(out, "%s is not in the ideal generated by LPP(MCCGB).", string(lpp_X(p1)));
	}
    } else {
      fprintf(out, "%s is not in the ideal generated by MCCGB.", string(p));
    }

    
    // Otherwise, p is essential.
    return (1);
}

proc listDeleteByPoly(list l, poly f) {
  int i;
  if (size(l) == 0) {
    return (list());
  } else {
    for (i = 1; i <= size(l); i++) {
      if (l[i] == f || l[i] == -f) {
	return (delete(l, i));
      }
    }
    return (l);
  }
}

proc appearInBranch(poly f, list branch) {
  // Basering is @RP.
  if (size(branch[3]) == 0) {
    return (0);
  } else {
    int i;
    for (i = 1; i <= size(branch[3]); i++) {
      poly g = branch[3][i][1] + branch[3][i][2];
      if (g == f || g == -f) {
	return (1);
      } else {
	// Check whether g = h * f, 
	// where h is in k[U].
	//poly quotient = g / f;
	//poly remainder = g - g/f * f;
	//if (lpp_X(quotient) == 1 && remainder == 0) {
	//return (1);
	//}
      }
    }
    return (0);
  }
}

proc genPPs(poly f) {
  // Basering is @RP.
  if (f == 0) {
    return (list(0));
  } else {
    list res_list;
    while(f != 0) {
      res_list = insert(res_list, lpp_X(f), size(res_list));
      f = f - lm_X(f);
    }
    return (res_list);
  }
}

proc checkCoefZero(poly c, ideal E) {
  // Basering is @RP.
  ideal GE = radical(E);
  
  poly rem = reduce(c, GE);
  if (rem == 0) {
    return (1);
  } else {
    return (0);
  }

  
}

proc getCoefOfPP(poly pp, poly f) {
  // Basering is @RP.
  poly c;
  while (f != 0) {
    if (lpp_X(f) == pp) {
      c = leadcoef_X(f);
      break;
    } else {
      f = f - lm_X(f);
    }
  }

  return (c);
}

proc listContains(poly f, list l) {
  if (size(l) == 0) {
    return (0);
  } else {
    int i;
    for (i = 1; i <= size(l); i++) {
      if (f == l[i] || -f == l[i]) {
	return (1);
      }
    }
    return (0);
  }
}

proc checkCoefNonnull(poly c, list N) {
  // Basering is @RP.
  if (size(N) == 1) {
    N[1] = 1;
  }

  poly nonnull_cond = 1;
  int i;
  for (i = 1; i <= size(N); i++) {
    nonnull_cond = nonnull_cond * N[i];
  }

  if (verify_with_nonnull(c, nonnull_cond) != 0) {
    // c is determined to be non-zero.
    return (1);
  } else {
    return (0);
  }
}

proc genCandidateFaithfulPolys(poly lpp_f, list G, ideal E, list N) {
  // Basering is @RP.
  if (size(G) == 0) {
    return (list());
  }

  int i;
  list res_list;
  for (i = 1; i <= size(G); i++) {
    poly c = getCoefOfPP(lpp_f, G[i]);
    if (!checkCoefZero(c, E)) {
      res_list = insert(res_list, G[i], size(res_list));
    }
  }

  return (res_list);
}

proc genCandidatePolys(poly lpp_f, list G, ideal E, list N) {
  // Basering is @RP.
  if (size(G) == 0) {
    return (list());
  } else {
    int i;
    list res_list;
    for (i = 1; i <= size(G); i++) {
      poly g = G[i];
      int candidate_flag = 1;
      if (listContains(lpp_f, genPPs(g))) {
	// Check coefficents of higher power-product.
	while (lpp_X(g) != lpp_f) {
	  poly c_higher = leadcoef_X(g);
	  if (checkCoefNonnull(c_higher, N)) {
	    // If any of them is determined to be non-zero,
	    // then g is not a candidate.
	    candidate_flag = 0;
	    break;
	  }
	  g = g - lm_X(g);
	}

	// Now check the coefficient of lpp_f in g.
	// If it's not determined to be zero,
	// then g is a candidate.
	if (candidate_flag) {
	  poly c = getCoefOfPP(lpp_f, g);
	  if (!checkCoefZero(c, E)) {
	    res_list = insert(res_list, g, size(res_list));
	  }
	}

      } // Endif.
    } // Endfor.
    return (res_list);
  } // Endif.
}

proc genConfigByPoly(poly pp, poly g, ideal E_branch) {
  // Basering is @RP.

  ideal GE_branch = radical(E_branch);

  // Construct E.
  list null_conds;
  poly f = g;
  while (lpp_X(f) != pp) {
    poly c = leadcoef_X(f);
    def rem_c = reduce(c, GE_branch);
    if (rem_c != 0) {
      null_conds = insert(null_conds, rem_c, size(null_conds));
    }
    f = f - lm_X(f);
  }
  def E = ideal(listToVec(null_conds));

  // Construct N.
  poly nonnull_cond = getCoefOfPP(pp, g);
  def rem_nonnull_cond = reduce(nonnull_cond, GE_branch);
  
  return (E, list(rem_nonnull_cond));
}

proc checkConfigConsistency(ideal E, list N) {
  // Switch to @AXU.
  vector N_vec = listToVec(N);
  def BR = basering;
  setring(@AXU);

  def E = imap(@RP, E);

  def N_vec = imap(@RP, N_vec);
  list N_raw = vecToList(N_vec);

  // Remove 0's from N.
  list N;
  for (i = 1; i<= size(N_raw); i++) {
    if (N_raw[i] != 0) {
      N = insert(N, N_raw[i], size(N));
    }
  }
  
  if (Check_Consistence_CGB(E, N)) {
    setring(BR);
    return (1);
  } else {
    setring(BR);
    return (0);
  }
}

proc ideal_exclude(ideal I, ideal J) {
  // Basering is @RP.
  if (size(I) == 0) {
    return (ideal());
  }

  if (size(J) == 0) {
    return (I);
  }
  
  poly prod_J = 1;
  int i, j;
  for (i = 1; i <= size(J); i++) {
    prod_J = prod_J * J[i];
  }
  ideal FL_J = factorize(prod_J, 1);

  for (i = 1; i <= size(I); i++) {
    for (j = 1; j <= size(FL_J); j++) {
      if (reduce(I[i], groebner(ideal(FL_J[j]))) == 0) {
	I[i] = I[i] / FL_J[j];
      }
    }
  }

  return (radical(I));
}

proc getNSquareFreeFromProd(poly h) {
  // Basering is @RP.
  ideal FL = factorize(h, 1);
  int i;
  list res_list;
  for (i = 1; i <= size(FL); i++) {
    res_list = insert(res_list, FL[i], size(res_list));
  }

  return (res_list);
}

proc redRepN(ideal E, list N, poly f) 
"
E, N are in red-representation.
If (E, N) is inconsistent, then E == ideal(1).
"
{
  // Basering is @RP.
  //ideal E1 = radical(E + ideal(f));
  ideal E1 = radical(E + ideal(f));

  poly h = 1;
  if (size(N) > 0) {
    int i;
    for (i = 1; i <= size(N); i++) {
      h = h * N[i];
    }
  }
  ideal res_E = ideal_exclude(E1, ideal(h));

  return (res_E, N);
}

proc redRepNN(ideal E, list N, poly f) 
"
E, N are in red-representation.
If (E, N) is inconsistent, then N == list().
"
{
  // Basering is @RP.
  int i;
  
  poly N_prod = 1;
  if (size(N) > 0) {
    for (i = 1; i <= size(N); i++) {
      N_prod = N_prod * N[i];
    }
  }
  poly h1 = reduce(N_prod * f, E);
  ideal newE = ideal_exclude(E, groebner(ideal(h1)));
  list newN = getNSquareFreeFromProd(h1);

  return (newE, newN);
}

proc splitBranch(ideal E, list N, poly f) 
"
E, N are in red-representation.
"
{
  // Basering is @RP.
  list res_list;

  ideal E0;
  list N0;
  (E0, N0) = redRepN(E, N, f);
  list sub1 = E0, N0;
  res_list = insert(res_list, sub1, size(res_list));
  if (groebner(E0)[1] == 1) {
    // (E0, N0) is inconsistent.
    list sub2 = E, N;
    res_list = insert(res_list, sub2, size(res_list));
  } else {
    ideal E1;
    list N1;
    (E1, N1) = redRepNN(E, N, f);
    list sub2 = E1, N1;
    res_list = insert(res_list, sub2, size(res_list));
  }

  return (res_list);
}

proc checkNonNull(poly f, ideal E, list N) {
  // Basering is @RP.
  ideal E_red;
  list N_red;
  (E_red, N_red) = makeRedRepresentation(E, N);

  list sub_branches = splitBranch(E_red, N_red, f);
  if (sub_branches[1][1] == 1) {
    return (1);
  }

  return (0);
}

proc makeRedRepresentation(ideal E, list N) {
  // Basering is @RP.
  int i;
  ideal newE;
  list newN;

  // E is trivial.
  if (size(E) == 0) {
    if (size(N) == 0) {
      // N is also trivial.
      return (ideal(), list(1));
    } else {
      // N is not trivial.
      newE = ideal();
    }
  }
  
  // N is trivial.
  if (size(N) == 0) {
    newN = 1;
  }

  // E is not trivial.
  if (size(E) > 0) {
    newE = radical(E);
  }

  // N is not trivial.
  if (size(N) > 0) {
    poly prod_N = 1;
    for (i = 1; i <= size(N); i++) {
      prod_N = prod_N * N[i];
    }

    poly prod_N_rem = reduce(prod_N, newE);

    ideal FL_N = factorize(prod_N_rem, 1);

    list newN;
    for (i = 1; i <= size(FL_N); i++) {
      newN = insert(newN, FL_N[i], size(newN));
    }
  }

  return (newE, newN);
}

// Yiming: Will be obsolete once checkEssentialInBranch is done.
proc checkConfigUnionWithBranch(list config_list, ideal E, list N) {
  // Basering is @RP.
  if (size(config_list) == 0) {
    return (0);
  }

  ideal GE = radical(E);

  if (size(N) == 0) {
    N[1] = 1;
  }

  poly N_prod = 1;
  for (i = 1; i <= size(N); i++) {
    N_prod = N_prod * N[i];
  }
  list N_fact = factorize(N_prod, 1);


  int i, j;
  poly null_prod = 1;
  poly nonnull_prod = 1;
  for (i = 1; i <= size(config_list); i++) {
    if (size(config_list[i][1]) != 0) {
      for (j = 1; j <= size(config_list[i][1]); j++) {
	null_prod = null_prod * config_list[i][1][j];
      }
    } else {
      null_prod = 0;
    }
    
    for (j = 1; j <= size(config_list[i][2]); j++) {
      nonnull_prod = nonnull_prod * config_list[i][2][j];
    }
  }

  // Factorize both of the products.
  ideal null_FL = factorize(null_prod, 1);
  ideal nonnull_FL = factorize(nonnull_prod, 1);

  // One direction: for each poly in null_FL but not in E,
  // check whether its corresponding poly is in nonnull_FL. 
  for (i = 1; i <= size(null_FL); i++) {
    poly cur_factor = null_FL[i];
    if (reduce(cur_factor, GE) != 0) {
      if (reduce(cur_factor, nonnull_FL) != 0) {
	return (0);
      }
    }
  }

  // Backward: for each poly in nonnull_FL but not in N,
  // check whether its corresponding poly is in null_FL.
  for (i = 1; i <= size(nonnull_FL); i++) {
    poly cur_factor = nonnull_FL[i];
    if (!listContains(cur_factor, N_fact[1])) {
      if (reduce(cur_factor, null_FL) != 0) {
	return (0);
      }
    }
  }

  return (1);
}

proc checkNullRedRep(ideal E, list N, poly f) 
"
E, N are in red-representation.
"
{
  // Basering is @RP.
  if (reduce(f, groebner(E)) == 0) {
    return (1);
  }

  return (0);
}

proc checkNonNullRedRep(ideal E, list N, poly f)
"
E, N are in red-representation.
"
{
  // Basering is @RP.
  ideal newE;
  list newN;
  (newE, newN) = redRepN(E, N, f);
  if (groebner(newE)[1] == 1) {
    return (1);
  }

  return (0);
}

proc getHigherCoefs(poly f, poly t) {
  // Basering is @RP.
  list res_list;
  while (lpp_X(f) > t) {
    res_list = insert(res_list, leadcoef_X(f), size(res_list));
    f = f - lm_X(f);
  }

  return (res_list);
}

// TODO
proc checkEssentialInBranch(poly t, list G, ideal E, list N, link out) {
  // Basering is @RP.
  int i;
  fprintf(out, "-----------------------------------");
  fprintf(out, "Now come to Branch (<%s>, <%s>):", string(E), string(N));


  // t is the LPP_X(g) currently used.
  list candidates = genCandidateFaithfulPolys(t, G, E, N);
  
  if (size(candidates) == 0) {
    fprintf(out, "There is no candidate poly.");
    return (1);
  }

  // Transform E and N into red-representation.
  ideal E_red;
  list N_red;
  (E_red, N_red) = makeRedRepresentation(E, N);
  fprintf(out, "Red-presentation of (E, N) is:");
  fprintf(out, "<%s>, {%s}.", string(E_red), string(N_red));
  fprintf(out, "Candidate list is [");
  show_list_to_file(candidates, out);
  fprintf(out, "].");

  poly f = candidates[1];
  list raw_higher_coefs = getHigherCoefs(f, t);
  
  // reduce each poly in raw_higher_coefs by E_red.
  list higher_coefs;
  if (size(raw_higher_coefs) > 0) {
    ideal GE_red = groebner(E_red);
    for (i = 1; i <= size(raw_higher_coefs); i++) {
      poly rem = reduce(raw_higher_coefs[i], GE_red);
      if (rem != 0) {
	higher_coefs = insert(higher_coefs, rem, size(higher_coefs));
      }
    }
  }

  // Get coefficient of LPP t.
  poly ct = getCoefOfPP(t, f);
  
  list sub_branches = splitBranch(E_red, N_red, ct);
  ideal E0 = sub_branches[1][1];
  list N0 = sub_branches[1][2];
  ideal E1 = sub_branches[2][1];
  list N1 = sub_branches[2][2];

  fprintf(out, "Split (E, N) into two sub-branches wrt %s:", string(ct));
  fprintf(out, "Sub-branch 1: (<%s>, {%s});", string(E0), string(N0));
  fprintf(out, "Sub-branch 2: (<%s>, {%s}).", string(E1), string(N1));

  // Case I: ct is enforced to be 0.
  if (size(N1) == 0) {
    // Consider the rest candidates.
    fprintf(out, "coef(%s) = %s is enforced to be 0", string(f), string(ct));
    return (checkEssentialInBranch(t, delete(G, 1), E0, N0, out))
  }

  // Case II: ct is enforced to be non-zero.
  if (groebner(E0)[1] == 1) {
    fprintf(out, "coef(%s) = %s is enforced to be non-zero.", string(f), string(ct));

    if (size(higher_coefs) == 0) {
      fprintf(out, "And there is no non-zero higher term. g is covered in Branch <%s>, {%s}.", string(E1), string(N1));
      return (0);
    } else {
      fprintf(out, "But there are some non-zero higher terms in f.");
      list G_rem = listDeleteByPoly(G, f);
      ideal E_rem = E1;
      list N_rem = N1;
      ideal E_cur;
      list N_cur;
      // Consider each coefficient of higher terms.
      for (i = 1; i <= size(higher_coefs); i++) {
	// Split further only if the coef is not enforced.
	if (checkNonNull(higher_coefs[i], E_rem, N_rem) != 0) {
	  // higher_coefs[i] is enforced to be non-zero.
	  fprintf(out, "%s is enforced to be non-zero.", string(higher_coefs[i]));
	  if (checkEssentialInBranch(t, G_rem, E_rem, N_rem, out)) {
	    fprintf(out, "Thus, g is essential in Branch <%s>, {%s}.", string(E_rem), string(N_rem));
	    return (1);
	  } else {
	    fprintf(out, "g is covered in Branch <%s>, {%s}.", string(E_rem), string(N_rem));
	    return (0);
	  }
	} else {
	  fprintf(out, "%s is either zero or not.", string(higher_coefs[i]));
	}
	
	sub_branches = splitBranch(E_rem, N_rem, higher_coefs[i]);
	fprintf(out, "Split (<%s>, {%s}) wrt %s:", string(E_rem), string(N_rem), string(higher_coefs[i]));
	E_rem = sub_branches[1][1];
	N_rem = sub_branches[1][2];
	E_cur = sub_branches[2][1];
	N_cur = sub_branches[2][2];
	fprintf(out, "Sub-branch 1: (<%s>, {%s});", string(E_rem), string(N_rem));
	fprintf(out, "Sub-branch 2: (<%s>, {%s}).", string(E_cur), string(N_cur));

	// For sub-branch in which higher_coefs[i] is non-zero.
	if (checkEssentialInBranch(t, G_rem, E_cur, N_cur, out)) {
	  fprintf(out, "g is essential in Sub-Branch <%s>, {%s}.", string(E_cur), string(N_cur));
	  fprintf(out, "Thus, g is essential in Branch <%s>, {%s}.", string(E1), string(N1));
	  return (1);
	} else {
	  fprintf(out, "g is covered in Sub-Branch <%s>, {%s}.", string(E_cur), string(N_cur));
	  // Consider the remaining sub-branch where higher_coefs[i] is zero.
	  continue;
	} // Endif.
      } // Endfor.
      
      fprintf(out, "Thus, g is non-essential in Branch <%s>, {%s}.", string(E1), string(N1));
      return (0);
    }
  }

  fprintf(out, "coef(%s) = %s is either zero or not.", string(f), string(ct));
  // Case III: both sub-branches are consistent.
  if (size(higher_coefs) == 0) {
    // There is no higher monomial under specialization.
    fprintf(out, "There is no non-zero higher term in %s under <%s>, <%s>.", string(f), string(E_red), string(N_red));
    fprintf(out, "g is covered in Sub-Branch 2: <%s>, {%s}.", string(E1), string(N1));
    fprintf(out, "We still need to check Sub-Branch 1.");
    return (checkEssentialInBranch(t, delete(G, 1), E0, N0, out));
  } else {
    fprintf(out, "But there are some non-zero higher terms in f.");
    // Consider (E1, N1).
    list G_rem = listDeleteByPoly(G, f);
    ideal E_rem = E1;
    list N_rem = N1;
    ideal E_cur;
    list N_cur;
    // Consider each coefficient of higher terms.
    for (i = 1; i <= size(higher_coefs); i++) {
      // Split further only if the coef is not enforced.
      poly nonnull = 1;
      int j;
      if (size(N_rem) > 0) {
	for (j = 1; j <= size(N_rem); j++) {
	  nonnull = nonnull * N_rem[j];
	}
      }
      if (checkNonNull(higher_coefs[i], E_rem, N_rem) != 0) {
	// higher_coefs[i] is enforced to be non-zero.
	fprintf(out, "%s is enforced to be non-zero.", string(higher_coefs[i]));
	if (checkEssentialInBranch(t, G_rem, E_rem, N_rem, out)) {
	  fprintf(out, "Thus, g is essential in Branch <%s>, {%s}.", string(E_rem), string(N_rem));
	  return (1);
	} else {
	  fprintf(out, "g is covered in Branch <%s>, {%s}.", string(E_rem), string(N_rem));
	  break;
	}
      } else {
	fprintf(out, "%s is either zero or not.", string(higher_coefs[i]));
      }

      fprintf(out, "Split (<%s>, {%s}) wrt %s:", string(E_rem), string(N_rem), string(higher_coefs[i]));
      sub_branches = splitBranch(E_rem, N_rem, higher_coefs[i]);
      E_rem = sub_branches[1][1];
      N_rem = sub_branches[1][2];
      E_cur = sub_branches[2][1];
      N_cur = sub_branches[2][2];
      fprintf(out, "Sub-branch 1: (<%s>, {%s});", string(E_rem), string(N_rem));
      fprintf(out, "Sub-branch 2: (<%s>, {%s}).", string(E_cur), string(N_cur));
      

      // For sub-branch in which higher_coefs[i] is non-zero.
      if (checkEssentialInBranch(t, G_rem, E_cur, N_cur, out)) {
	fprintf(out, "g is essential in Sub-Branch <%s>, {%s}.", string(E_cur), string(N_cur));
	fprintf(out, "Thus, g is essential in Branch <%s>, {%s}.", string(E1), string(N1));
	return (1);
      } else {
	fprintf(out, "g is covered in Sub-Branch <%s>, {%s}.", string(E_cur), string(N_cur));
	// Consider the remaining sub-branch where higher_coefs[i] is zero.
	continue;
      } // Endif.
    } // Endfor.

    fprintf(out, "Thus, g is non-essential in Branch <%s>, {%s}.", string(E1), string(N1));

    // Now consider (E0, N0).
    fprintf(out, "But we still need to check Branch <%s>, {%s}.", string(E0), string(N0));
    if (checkEssentialInBranch(t, G_rem, E0, N0, out)) {
      fprintf(out, "g is essential in Sub-Branch <%s>, {%s}.", string(E0), string(N0));
      fprintf(out, "Thus, g is essential in Branch <%s>, {%s}.", string(E_red), string(N_red));
      return (1);
    } else {
      fprintf(out, "Thus, g is non-essential in Branch <%s>, {%s}.", string(E_red), string(N_red));
      return (0);
    }

  } // End of Case III.

}

// Used for top-down algorithm.
proc checkEssential(poly g, list G, list modcgs, link out) {
  // Basering is @RP.
  int i, j;
  
  if (size(modcgs) == 0) {
    fprintf(out, "CGS is empty!");
    return (1);
  }

  for (i = 1; i <= size(modcgs); i++) {
    // For each branch in which g appears.
    if (appearInBranch(g, modcgs[i])) {
      // G_i is guaranteed to be non-empty.

      // Compute nonnull_cond.
      poly nonnull_cond = 1;
      if (size(modcgs[i][2]) != 0) {
	for (j = 1; j <= size(modcgs[i][2]); j++) {
	  nonnull_cond = nonnull_cond * modcgs[i][2][j];
	}
      }

      fprintf(out, "**********************************");
      fprintf(out, "Come to Branch %s:", string(i));
      fprintf(out, "[%s],    [%s].", string(modcgs[i][1]), string(modcgs[i][2]));

      fprintf(out, "Faithful sigma(G_%s) = [", string(i));
      show_list_to_file(get_nonzero_part(modcgs[i][3]), out);
      fprintf(out, "].");

      // Compute LPP_X(sigma(g)).
      poly lpp_g;
      for (j = 1; j <= size(modcgs[i][3]); j++) {
	if (g == modcgs[i][3][j][1] + modcgs[i][3][j][2]) {
	  lpp_g = lpp_X(modcgs[i][3][j][1]);
	}
      }
      fprintf(out, "LPP_X(sigma(g)) = %s.", string(lpp_g));

      if (checkEssentialInBranch(lpp_g, listDeleteByPoly(G, g), modcgs[i][1], modcgs[i][2], out)) {
	fprintf(out, "g is essential in Branch %s.", string(i));
	return (1);
      } else {
	fprintf(out, "g is non-essential in Branch %s.", string(i));
      } // Endif.

    } // Endif.
  } // Endfor.
  
  // Now g is non-essential for all branches in which it appears.
  // Thus g is non-essential globally.
  return (0);
}

proc genMCCGB_topdown(ideal Polys, ideal Equ, list DisEqu, link out) {
  // Basering is @R.
  ideal G;
  list modcgs;

  (G, modcgs) = cgb_mod(Polys, Equ, DisEqu, out);
  set_global_rings_mccgb();

  // Switch to @RP.
  setring(@RP);
  def G = imap(@R, G);
  def modcgs = imap(@R, modcgs);

  fprintf(out, newline + "==========================");
  fprintf(out, "Now remove non-essential poly:");
  fprintf(out, "==========================");

  list mccgb;
  int i, j;

  // Initially, set G to be mccgb.
  for (i = 1; i <= size(G); i++) {
    mccgb[i] = G[i];
  }
  fprintf(out, "Initially, M = {");
  show_list_to_file(mccgb, out);
  fprintf(out, "}.");

  // For each poly in mccgb.
  for (i = 1; i <= size(G); i++) {
    poly cur_g = G[i];
    fprintf(out, "++++++++++++++++++++++++++++++++++");
    fprintf(out, "Now consider %s:", string(cur_g));
    mccgb = listDeleteByPoly(mccgb, cur_g);
    fprintf(out, "M' = {");
    show_list_to_file(mccgb, out);
    fprintf(out, "}.");
    
    if (checkEssential(cur_g, mccgb, modcgs, out)) {
      fprintf(out, "%s is essential.", string(cur_g));
      mccgb = insert(mccgb, cur_g, size(mccgb)); 
    } else {
      fprintf(out, "%s is not essential.", string(cur_g));
    }
  }

  // Switch back to @R.
  setring(@R);
  def mccgb = imap(@RP, mccgb);
  def G = imap(@RP, G);
  def modcgs = imap(@RP, modcgs);

  fprintf(out ,newline + "=================================");

  return (mccgb, G, modcgs);
     
}

proc genMCCGB(ideal Polys, ideal Equ, list DisEqu, link out) {


	// Base ring is @R.

        ideal G;
	list modcgs;
	
	(G, modcgs) = cgb_mod(Polys, Equ, DisEqu, out);
	set_global_rings_mccgb();


	// Switch to @RP.
	setring(@RP);
	def G = imap(@R, G);
	def modcgs = imap(@R, modcgs);

	fprintf(out, newline + "============================");
	fprintf(out, "Now construct MCCGB:");

	list mccgb;
	int i, j;

	// Add the first branch.
	for (j = 1; j <= size(modcgs[1][3]); j++) {
	    mccgb[j] = modcgs[1][3][j][1] + modcgs[1][3][j][2];
	}
	fprintf(out, newline + "-------------------------");
	fprintf(out, "After adding the first branch:");
	fprintf(out, "MCCGB = {%s}", string(mccgb));

	if (size(modcgs) > 1) {
	    // Consider each branch.
	  fprintf(out, newline + "---------------------");
	  fprintf(out, "Consider each branch:" + newline);
	    for (i = 2; i <= size(modcgs); i++) {
		list null_conds;
	        fprintf(out, newline+"Coming to Branch %s: ({%s}, {%s}):", string(i), string(modcgs[i][1]), string(modcgs[i][2]));

	        // If Groebner Basis of the branch is empty, then pass.
	        if (size(modcgs[i][3]) != 0) {
		    // Build the list of null conditions.
	            for (j = 1; j <= size(modcgs[i][1]); j++) {
			null_conds = insert(null_conds, modcgs[i][1][j], size(null_conds));
	            }

	            // For each polynomial in the Groebner Basis.
	            for (j = 1; j <= size(modcgs[i][3]); j++) {
			poly p1 = modcgs[i][3][j][1];
	                poly p0 = modcgs[i][3][j][2];
	                poly p = p1 + p0;

	                fprintf(out, newline+"Currently consider polynomial P = %s.", string(p));

	                if (Check_Essential(p, p1, mccgb, modcgs[i][1], modcgs[i][2], out) == 1) {
			    // p is essential, add to mccgb.
			  fprintf(out, "%s is essential.", string(p));
	                  mccgb = insert(mccgb, p, size(mccgb));
	                } else {
			  fprintf(out, "%s is not essential.", string(p));
			}
	            } 
	        }

	    }
	}

	// Switch back to @R.
	setring(@R);
	def mccgb = imap(@RP, mccgb);
	def G = imap(@RP, G);
	def modcgs = imap(@RP, modcgs);

	fprintf(out, newline + "================================");
	

	return(mccgb, G, modcgs);
}

proc showMCCGB(list mccgb, link out) {
    int i;

    fprintf(out, "The MCCGB is:" + newline );
    if (size(mccgb) == 0) {
        fprintf(out, "{  }." + newline);
    } else {
	for (i = 1; i < size(mccgb); i++) {
	    fprintf(out, "%s,", mccgb[i]);
	}
	fprintf(out, "%s." + newline, mccgb[size(mccgb)]);
    }
}

proc get_nonzero_part(list l) {
    int i;
    list res_list;

    for (i = 1; i <= size(l); i++) {
	res_list[i] = l[i][1];
    }

    return (res_list);
}

proc is_multiple(poly p1, poly p2) {

  if (nameof(basering) != "@RP") {
    def BR = basering;
    setring(@RP);
    def p1 = imap(BR, p1);
    def p2 = imap(BR, p2);
  }
  
  if (p1 == 0 || p2 == 0) {
    setring(BR);
    return (0);
  } else {
    poly quo1 = p1 / p2;
    poly rem1 = p1 - (p1 / p2) * p2;

    if (lpp_X(quo1) == 1 && rem1 == 0) {
      setring(BR);
      return (1);
    } else {
      poly quo2 = p2 / p1;
      poly rem2 = p2 - (p2 / p1) * p1;
      
      if (lpp_X(quo2) == 1 && rem2 == 0) {
	setring(BR);
	return (1);
      } else {
	setring(BR);
	return (0);
      }
    }

  }
  
}

// BUG: is_sublist(list(ux, 1), list(vx, 1)) == 1.
// TODO.
proc is_sublist(list l1, list l2) 
"INPUT:    l1, l2 are two lists of polynomials.
RETURN:    1 if for any poly f in l1, there is a multiple of f in l2;
           0 otherwise."
{
  // Basering is R[X, U].
  
  if (size(l1) == 0) {
    if (size(l2) == 0) {
      return (1);
    } else {
      return (0);
    }
  }

  if (size(l1) > size(l2)) {
    return (0);
  } else {
    // General case.
    int i, j;
    int flag;
    
    for (i = 1; i <= size(l1); i++) {
      flag = 0;
      // For each poly in l1.
      for (j = 1; j <= size(l2); j++) {
	if (is_multiple(l1[i], l2[j])) {
	  flag = 1;
	  break;
	}
      }
      if (flag == 0) {
	return (0);
      }
    }
    return (1);
  }


}

proc is_sublist_factorization(list l1, list l2) 
"INPUT:    l1, l2 are two lists with identical structures. 
           Take l1 as an example, l1[1] is a list of poly factors,
           l1[2] is the list of degrees for the corresponding factor in l1[1]"
{
  // Base ring is Q[X, A].
  int i, j;

  int N1 = size(l1[1]);
  int N2 = size(l2[1]);

  if (N1 == 0) {
    return (1);
  } else {
    if (N2 == 0) {
      return (0);
    }
  }

  // General case.
  int cnt = 0;
  for (i = 1; i <= size(l1[1]); i++) {
    for (j = 1; j <= size(l2[1]); j++) {
      // l1[1][i] = {+1, -1} * l2[1][j]
      if (l1[1][i] == l2[1][j] || l1[1][i] == -l2[1][j]) {
	cnt = cnt + 1;
	break;
      }
    }
  }

  if (cnt == N1) {
    return (1);
  } else {
    return (0);
  }

}

proc verify_with_nonnull(poly p, poly nonnull_cond) 
"USAGE:    Judge whether p is determined to be non-zero or not.
INPUT:     p -- Polynomial in Q[A], which is usually LC_A(t) for 
                some monomial t in poly f.
RETURN:    0 if not determined to be non-zero; p itself otherwise."
{
  // Base ring is Q[X, A].

  if (leadmonom(p) == 1) {
    // p is a constant, i.e. p is enforced to be non-zero.
    return (p);
  }

  // Factorize the product n_poly and p. We only care about non-constant factors with no multiplicity.
  list FL = factorize(nonnull_cond, 1);
  list LCFL = factorize(p, 1);

  if (is_sublist_factorization(LCFL, FL)) {
    // LCFL is a subset of FL.
    return (p);
  }

  return (0);
}

proc is_poly_nonnull(poly f, list nonnull_conds) 
"RETURN:    1 if some of the coefficients of f is enforced to be non-zero under nonnull_conds;
            0 otherwise."
{
  // Base ring is Q[X, A].

  if (size(nonnull_conds) == 0) {
    // Everything is enforced to be non-zero.
    return (1);
  }
 
  
  list coef_list = get_coef_list(f);
  if (size(coef_list) == 0) {
    return (0);
  } else {
    int i;
    int null_cnt = 0;
    for (i = 1; i <= size(coef_list); i++) {
      poly cur_coef = coef_list[i];
      if (verify_with_nonnull(cur_coef, nonnull_conds) == 0) {
	// cur_coef is not enforced to be non-zero.
	null_cnt = null_cnt + 1;
      }
    }
    if (null_cnt == size(coef_list)) {
      // Each coefficient is not enforced to be non-zero. Thus, we can regard f -> 0.
      return (0);
    } else {
      return (1);
    }
  }

}


proc get_sigma_basis_with_single_nonnull(list basis, ideal E, poly nonnull_cond, int flag) {
  int i;
  if (flag) {
    for (i = 1; i <= size(basis); i++) {
      basis[i] = basis[i][1] + basis[i][2];
    }
  }

  int trivial_nonnull = 0;
  if (nonnull_cond == 1) {
    trivial_nonnull = 1;
  }

  // Switch to Q[X, A].
  int switch_flag = 0;
  if (nameof(basering) != "@RP") {
    def BR = basering;
    setring(@RP);
    switch_flag = 1;
    def basis = imap(BR, basis);
    def E = imap(BR, E);
    if (trivial_nonnull) {
      def nonnull_cond = 1;
    } else {
      def nonnull_cond = imap(BR, nonnull_cond);
    }
  }

  vector v;
  list sigma_basis;
  
  ideal GE = groebner(radical(E));
  def rem_nonnull_cond = reduce(nonnull_cond, GE);

  for (i = 1; i <= size(basis); i++) {
    poly p = basis[i];
    poly p1 = 0;
    int lpp_set = 0;
    while (p != 0) {
      def rem = reduce(leadcoef_X(p), GE);
      if (rem != 0) {
	// coefficient is not enforced to be 0.
	// Further check: Whether it's nonnull.
	// First, we must use remainder of nonnull_cond divided by GE.
	if (!lpp_set) {
	  if (verify_with_nonnull(rem, rem_nonnull_cond) != 0) {
	    // We get the lpp(sigma(p)).
	    p1 = p1 + rem * lpp_X(p);
	    lpp_set = 1;
	  } else {
	    // rem is either 0 or not.
	    p1 = p1 + rem * lpp_X(p);
	  }
	} else {
	  // lpp(sigma(p)) is alreay set.
	  p1 = p1 + rem * lpp_X(p);
	}
      }
      p = p - lm_X(p);
    } // End while.
    
    if (p1 != 0) {
      // Add p1 into sigma(basis) only if it's non-zero.
      sigma_basis = insert(sigma_basis, p1, size(sigma_basis));
    }

  } // End for.

  // The case that sigma(basis) is empty should be processed separately.
  int empty_flag = size(sigma_basis);

  // Switch back to Q[A][X].
  if (switch_flag) {
    setring(BR);
    if (empty_flag == 0) {
      def sigma_basis = 0;
    } else {
      def sigma_basis = imap(@RP, sigma_basis);
    }
  }

  return (sigma_basis);

}

proc get_sigma_basis(list basis, ideal E, list nonnull_conds, int flag) 
"USAGE:    Get the basis under the specialization set by null_conds.
           If flag != 0, then basis is from CGS, which needs to eliminate
           auxiliary variables first.
RETURN:    Basis under the given specialization."
{
  int i;
  if (flag) {

    for (i = 1; i <= size(basis); i++) {
      basis[i] = basis[i][1] + basis[i][2];
    }
  }

  //if (size(null_conds) == 0) {
  //  return (basis);
  //}

  // Switch to Q[X, A].
  def BR = basering;
  setring(@RP);
  def basis = imap(BR, basis);
  def E = imap(BR, E);

  // Copy null_conds to Q[X, A]
/*if (!defined(null_conds)) {
    def null_conds = imap(BR, null_conds);
  } else {
    if (size(null_conds) > 0) {
      def null_conds = imap(BR, null_conds);
    }
  }*/

  // Copy nonnull_conds to Q[X, A].
  if (!defined(nonnull_conds)) {
    def nonnull_conds = imap(BR, nonnull_conds);
  } else {
    if (size(nonnull_conds) > 0) {
      def nonnull_conds = imap(BR, nonnull_conds);
    }
  }


  vector v;
  list sigma_basis;
  /*
  if (size(null_conds) > 0) {
    for (i = 1; i <= size(null_conds); i++) {
      v = v + gen(i) * null_conds[i];
    }
    }*/

  //ideal E = radical(ideal(v));
  ideal GE = groebner(radical(E));

  for (i = 1; i <= size(basis); i++) {
    poly p = basis[i];
    poly p1 = 0;
    while (p != 0) {
      def rem = reduce(leadcoef_X(p), GE);
      if (rem != 0) {
	//p1 = p1 + rem * lpp_X(p);
	p1 = p1 + lm_X(p);
      }
      p = p - lm_X(p);
    } // End of while.
    if (p1 != 0) {
      // Yiming
      // Further check: whether p1 is enforced to be non-zero w.r.t. N.
      //if (is_poly_nonnull(p1, nonnull_conds)) {
	// Some of its coefficients is enforced to be non-zero.
	sigma_basis = insert(sigma_basis, p1, size(sigma_basis));
	//}
    }
  } // End of for.

  // The case that sigma(basis) is empty should be processed specially.
  int empty_flag = size(sigma_basis);

  // Switch back to Q[A][X].
  setring(BR);
  if (empty_flag == 0) {
    def sigma_basis = 0;
  } else {
    def sigma_basis = imap(@RP, sigma_basis);
  }

  return (sigma_basis);
}

proc check_ideal_equality(list g1, list g2, ideal E) 
"USAGE:    Check whether ideals <g1> and <g2> are equivalent.
RETURN:    1 if they are equivalent; 0 otherwise."
{
  // Basering is Q[A][X].
  def I_ideal_equality = groebner(ideal(listToVec(g1)));
  def J_ideal_equality = groebner(ideal(listToVec(g2)));
  int i;
  int flag = 1;
  poly rem_ideal_equality;

  for (i = 1; i <= size(g1); i++) {
    rem_ideal_equality = reduce(g1[i], J_ideal_equality);
    if (rem_ideal_equality != 0) {
      // If remainder is not 0,
      // then switch to Q[X, A].
      rem_ideal_equality = rem_ideal_equality * denominator(number(rem_ideal_equality));
      setring(@RP);
      def J_ideal_equality = imap(@R, J_ideal_equality);
      def rem_ideal_equality = imap(@R, rem_ideal_equality);
      def E = imap(@R, E);

      // Check whether rem can be reduced to 0 under radical of E.
      if (!rad_con(rem_ideal_equality, E)) {
      	 flag = 0;
	 setring(@R);
	 break;
      } else {
         setring(@R);
      }

    }
  }


  if (flag != 0) {
    for (i = 1; i <= size(g2); i++) {
      rem_ideal_equality = reduce(g2[i], I_ideal_equality);
      if (rem_ideal_equality != 0) {
        // If rem is not 0, switch to Q[X, A].
	rem_ideal_equality = rem_ideal_equality * denominator(number(rem_ideal_equality));
	setring(@RP);
	def I_ideal_equality = imap(@R, I_ideal_equality);
	def rem_ideal_equality = imap(@R, rem_ideal_equality);
	def E = imap(@R, E);

	// Check whether rem can be reduced to 0 under radical of E.
	if (!rad_con(rem_ideal_equality, E)) {
	  flag = 0;
	  setring(@R);
	  break;
	} else {
	  setring(@R);
	}
      }
    }
  }


  return (flag);
}

proc show_list_to_file(list l, link out) {
  int i;
  if (size(l) == 0) {
    fprintf(out, newline);
  } else {
    for (i = 1; i <= size(l); i++) {
      fprintf(out, "        %s,", string(l[i]));
    }
  }
}

proc check_comprehensive_with_single_nonnull(list basis, ideal modcgs_E, poly nonnull_cond, list modcgs_g, link out) {
  // Basering is R[U][X].
  if (size(modcgs_g) != 0) {
    // G_i is not empty.
    def sigma_g_reference = get_nonzero_part(modcgs_g);
    def sigma_g = get_sigma_basis_with_single_nonnull(modcgs_g, modcgs_E, nonnull_cond, 1);
    def sigma_basis = get_sigma_basis_with_single_nonnull(basis, modcgs_E, nonnull_cond, 0);

    fprintf(out, "      original sigma(g) = [");
    show_list_to_file(sigma_g_reference, out);
    fprintf(out, "      ];");
    fprintf(out, "      sigma(g) = [");
    show_list_to_file(sigma_g, out);
    fprintf(out, "      ];");
    fprintf(out, "      sigma(basis) = [");
    show_list_to_file(sigma_basis, out);
    fprintf(out, "      ].");
    
    if (check_groebner_new(basis, sigma_basis, modcgs_g, sigma_g, modcgs_E)) {
      return (1);
    } else {
      return (0);
    }

    /*
    if (check_groebner_new(basis, sigma_basis, modcgs_g, modcgs_E)) {
      // Check whether <sigma(basis)> \subset <sigma(g)>.
      int j;
      for (j = 1; j <= size(sigma_basis); j++) {
	def rem = reduce(sigma_basis[j], ideal(listToVec(sigma_g)));
	if (rem == 0 || reduce(rem, modcgs_E) == 0) {
	  return (1);
	} else {
	  return (0);
	}
      }
    
    } else {
      fprintf(out, "    sigma(basis) is not even a GB under [%s != 0].", string(nonnull_cond));
      return (0);
    }
    */
  } else {
    // G_i is empty.
    fprintf(out, "    sigma(g) is empty;");
    
    // Get sigma_basis.
    def sigma_basis = get_sigma_basis_with_single_nonnull(basis, modcgs_E, nonnull_cond, 0);
    fprintf(out, "    sigma(basis) = {%s}.", string(sigma_basis));

    if (sigma_basis[1] == 0) {
      fprintf(out, "    sigma(basis) is GB under [%s != 0].", string(nonnull_cond));
      return (1);
    } else {
      fprintf(out, "    sigma(basis) is not GB under [%s != 0].", string(nonnull_cond));
      return (0);
    }
  }

}

/*
proc check_comprehensive_with_nonnulls(list basis, ideal modcgs_E, list nonnull_conds, list modcgs_g, link out) 
{
  if (size(nonnull_conds) == 0) {
    poly nonnull_cond = 1;
    if (check_comprehensive_with_single_nonnull(basis, modcgs_E, nonnull_cond, modcgs_g, out)) {
      return (1);
    }

  } else {
    int i;
    for ( i = 1; i <= size(nonnull_conds); i++) {
      poly nonnull_cond = nonnull_conds[i];
      if (check_comprehensive_with_single_nonnull(basis, modcgs_E, nonnull_cond, modcgs_g, out)) {
	return (1);
      }
    }
  }

  return (0);
}
*/

proc check_comprehensiveness(list basis, list modcgs, link out) 
"USAGE:    Check whether mccgb is a comprehensive Groebner basis for the given CGS modcgs.
RETURN:    1 if mccgb is CGB; 0 otherwise."
{
  int i;
  int num_branches = size(modcgs);

  // For each branch ((E_i, N_i), G_i).
  for (i = 1; i <= num_branches; i++) {
    fprintf(out, newline + "  Branch %s: ({%s}, {%s}):", string(i), string(modcgs[i][1]), string(modcgs[i][2]));

    // Compute nonnull_cond.
    poly nonnull_cond = 1;
    if (size(modcgs[i][2]) != 0) {
      int j;
      for (j = 1; j <= size(modcgs[i][2]); j++) {
	nonnull_cond = nonnull_cond * modcgs[i][2][j];
      }
    }

    // Separate into cases due to N.
    if (check_comprehensive_with_single_nonnull(basis, modcgs[i][1], nonnull_cond, modcgs[i][3], out)) {
      fprintf(out, "  sigma(basis) is GB for Branch %s.", string(i));
    } else {
      fprintf(out, "  sigma(basis) is not GB for Branch %s.", string(i));
      // Temp: for dumping.
      //return (0);
    }


  } // End of for.

  return (1);

} // End of proc.

proc gen_indices(int MaxIdx, int MaxLen) {
  if (MaxIdx <= 0 || MaxLen <= 0) {
    return (list());
  } 

  int i;
  list res_list;
  for (i = 1; i <= MaxLen; i++) {
    res_list = res_list + gen_indices_sub(MaxIdx, i);
  }

  return (res_list);
}

proc gen_indices_sub(int T, int Len) {
  int i, j;
  list res_list;
  if (Len == 1) {
    for (i = 1; i <= T; i++) {
      res_list = insert(res_list, list(i), size(res_list));
    }
    return (res_list);
  }

  list sub_list = gen_indices_sub(T, Len - 1);
  for (i = 1; i <= size(sub_list); i++) {
    list cur_sub_list = sub_list[i];
    int starting_point = cur_sub_list[size(cur_sub_list)] + 1;
   
    if (starting_point <= T){
      for (j = starting_point; j <= T; j++) {
	list l = cur_sub_list;
	l = insert(l, j, size(l));
	res_list = insert(res_list, l, size(res_list));
      }
    }
  }

  return (res_list);
}

proc gen_sub_list(list l, int save_time) 
"USAGE:    Generate all the non-empty proper subsets of l.
RETURN:    A list of lists."
{
  int i, j;
  
  if (save_time) {
    // Only generate the largest proper subsets.
    list index_list = gen_indices_sub(size(l), size(l) - 1);
  } else {
    // Generate all the non-empty proper subsets.
    list index_list = gen_indices(size(l), size(l) - 1);
  }

  if (size(index_list) == 0) {
    return (list());
  }

  // General case.
  list sub_list;
  for (i = 1; i <= size(index_list); i++) {
    list cur_index_list = index_list[i];
    list res_list;
    for (j = 1; j <= size(cur_index_list); j++) {
      res_list = insert(res_list, l[cur_index_list[j]], size(res_list));
    }
    sub_list = insert(sub_list, res_list, size(sub_list));
  }

  return (sub_list);
}

proc get_coef_list(poly f) 
"USAGE:    Given parametric polynomial f in Q[A][X], 
           get the coefficients (only numerators) of all its monomials as list."
{
  int flag = 0;
  if (nameof(basering) != "@R") {
    def BR = basering;
    setring(@R);
    flag = 1;
    def f = imap(BR, f);
  }

  list res_list;

  while (f != 0) {
    poly lc = leadcoef(f);
    lc = lc * denominator(number(lc));
    res_list = insert(res_list, lc, size(res_list));

    f = f - lead(f);
  }

  if (flag == 1) {
    setring(BR);
    def res_list = imap(@R, res_list);
  }

  return (res_list);
}

proc check_coef_list_null(list coef_list, ideal E) 
"RETURN:    1 if all entries in coef_list can be reduced to 0 w.r.t. E.
            0 otherwise."
{
  // Base ring is Q[X, A].

  if (size(coef_list) == 0) {
    return (1);
  }

  int i;
  for (i = 1; i <= size(coef_list); i++) {
    poly cur_coef = coef_list[i];
    if (!rad_con(cur_coef, E)) {
      // cur_coef cannot be reduced to 0 under radical(E).
      return (0);
    }
  }

  return (1);
}

proc parametric_reduce(poly p, ideal I, ideal E) {
  // Basering is R[U][X].

  poly rem = reduce(p, I);
  if (rem == 0) {
    return (0);
  } else {
    list coef_list_rem = get_coef_list(rem);
    // Switch to @RP.
    setring(@RP);
    def E = imap(@R, E);
    def coef_list_rem = imap(@R, coef_list_rem);
    if (check_coef_list_null(coef_list_rem, E)) {
      // all coefficients reduce to 0.
      setring(@R);
      return (0);
    } else {
      setring(@R);
      return (1);
    }
  }
}

proc check_groebner_new(list basis, list sigma_basis, list modcgs_g, list sigma_g, ideal E) {
  // Basering is R[U][X].

  if (size(modcgs_g) == 0) {
    // G_i is empty.
    if (size(basis) != 0) {
      return (0);
    } else {
      return (1);
    }
  } else {
    int i, j;

    // Build G_i.
    list g_faithful;
    for (i = 1; i <= size(modcgs_g); i++) {
      g_faithful = insert(g_faithful, modcgs_g[i][1] + modcgs_g[i][2], size(g_faithful));
    }

    // Check whether G_i is a subset of basis.
    if (is_sublist(g_faithful, basis)) {
      // If so, basis is guaranteed to be GB.
      return (1);
    }

    // Otherwise, Build sigma(G_i).
    ideal sigma_I = groebner(listToVec(sigma_g));

    for (i = 1; i <= size(g_faithful); i++) {
      if (!is_sublist(list(g_faithful[i]), basis)) {
	// g[i] only appears in G_i.
	for (j = 1; j <= size(sigma_basis); j++) {
	  if (lpp_X(sigma_g[i]) == lpp_X(sigma_basis[j])) {
	    // We find a poly in basis which has the same LPP_X.
	    if (parametric_reduce(sigma_basis[j], sigma_I, E) != 0) {
	      // That polynomial is not in <sigma_G_i>.
	      return (0);
	    } else {
	      break;
	    }
	  } else {
	    if (j == size(sigma_basis)) {
	      // No poly in basis has the same LPP_X of sigma_g[i].
	      return (0);
	    }
	  }
	}
      }
    }

    return (1);

  }

}

proc check_groebner(list basis, ideal E) {
  // Basering is Q[A][X].
  if (size(basis) <= 1) {
    return(1);
  }

  int i, j;
  poly rem_check_groebner;
  ideal G_check_groebner = ideal(listToVec(basis));

  for (i = 1; i <= size(basis); i++) {
    for (j = 1; j <= size(basis); j++) {
      if (i != j) {
	poly f = spoly(basis[i], basis[j]);
	rem_check_groebner = reduce(f, G_check_groebner);
	if (rem_check_groebner != 0) {
	  // If the remainder is not 0, then switch to Q[X, A].
	  def coef_list = get_coef_list(rem_check_groebner);
	  setring(@RP);
	  def coef_list = imap(@R, coef_list);
	  def E = imap(@R, E);
	  
	  
	  // Check whether the remainder can be reduced to 0 under radical of E.
	  if (!check_coef_list_null(coef_list, E)) {
	    setring(@R);
	    //printf("S-Poly(f_%s, f_%s) mod basis != 0.", string(i), string(j));
	    return (0);
	  } else {
	    setring(@R);
	  }

	}
      }
    }
  }

  return (1);
}



proc check_minimality(list cgb, list modcgs, int save_time, link out) 
"USAGE:    Check whether cgb is minimal, given that it is already comprehensive.
RETURN:    1 if cgb is minimal; 0 otherwise."
{
  if (size(cgb) <= 1) {
    fprintf(out, "MCCGB is minimal!");
    return (1);
  }

  list sub_sets = gen_sub_list(cgb, save_time);

  if (save_time) {
    list idx_lists = gen_indices_sub(size(cgb), size(cgb) - 1);
  } else {
    list idx_lists = gen_indices(size(cgb), size(cgb) - 1);
  }

  int i, j;

  // For each largest proper subset of cgb.
  for (i = 1; i <= size(sub_sets); i++) {
    string subset_str = "{ ";
    list cur_idx_list = idx_lists[i];

    if (size(cur_idx_list) == 1) {
      subset_str = subset_str + "f_{" + string(cur_idx_list[1]) + "}";
    } else {
      for (j = 1; j < size(cur_idx_list); j++) {
	subset_str = subset_str + "f_{" + string(cur_idx_list[j]) + "}, ";
      }
      subset_str = subset_str + "f_{" + string(cur_idx_list[size(cur_idx_list)]) + "}";
    }

    subset_str = subset_str + " }";
    //fprintf(out, newline + "%s. Now Check the subset %s", string(i), subset_str);
    fprintf(out, newline + "%s. Now Check the subset [", string(i));
    show_list_to_file(sub_sets[i], out);
    fprintf(out, "    ]:");
    if (check_comprehensiveness(sub_sets[i], modcgs, out)) {
	// If the current proper subset of cgb is also a CGB,
        //  then cgb is not minimal.
        fprintf(out, "The subset MCCGB \\ {f_%s} is also CGB.", string(i));
	// Temp: for dumping.
	//return (0);
    }
  }

  return (1);
}

proc check_validity(list mccgb, list modcgs, int save_time, link out) 
"USAGE:    Check whether mccgb is minimal and comprehensive for the given CGS modcgs.
RETURN:    A string denoting why mccgb is not MCCGB;
           An integer flag denoting whether mccgb is valid (return (1)) or not (return (0)).
EXAMPLE:   (err_msg, flag) = check_validity(mccgb, Modcgs);"
{
  fprintf(out, newline + "===================================");
  fprintf(out, "Now check whether MCCGB is comprehensive and minimal:");
  fprintf(out, "-----------------");

  fprintf(out, "First, check the comprehensiveness of MCCGB:" + newline);

  if (check_comprehensiveness(mccgb, modcgs, out)) {
    // mccgb is comprehensive, then check the minimality.
    fprintf(out, newline + "MCCGB is comprehensive.");
    fprintf(out, newline + "------------------------");
    fprintf(out, "Second, check the minimality of MCCGB:");
    if (check_minimality(mccgb, modcgs, save_time, out)) {
      // mccgb is also minimal.
      fprintf(out, newline + "MCCGB is minimal.");
      return ("", 1);

    } else {
      // mccgb is not minimal.
      fprintf(out, newline + "MCCGB is not minimal.");
      return ("it is not minimal", 0);
    }

  } else {
    // mccgb is not comprehensive.
    fprintf(out, newline + "MCCGB is not comprehensive.");
    return ("it is not comprehensive", 0);
  }

}

proc alternativeMCCGB(ideal Polys, ideal Equ, list DisEqu, link out) {
  set_global_rings_mccgb();

  // Base ring is @R.
  def BR = basering;

  ideal G_alter;
  list modcgs_alter;

  (G_alter, modcgs_alter) = cgb_mod(Polys, Equ, DisEqu, out);
  // Switch to @RP.
  setring(@RP);
  def G_alter = imap(@R, G_alter);
  def modcgs_alter = imap(@R, modcgs_alter);

  // Initially, mccgb_alter equals to G_alter.
  list mccgb_alter;
  if (size(G_alter) > 0) {
    int i;
    for (i = 1; i <= size(G_alter); i++) {
      mccgb_alter[i] = G_alter[i];
    }
  }

  list Mark;
  // Create the list of occurrances for each poly in mccgb_alter.
  int i, j, k;
  if (size(mccgb_alter) > 0) {
    for (i = 1; i <= size(mccgb_alter); i++) {
      // For each poly in mccgb_alter.
      poly cur_poly = mccgb_alter[i];
      list temp_mark;
      if (size(modcgs_alter) > 0) {
	for (j = 1; j <= size(modcgs_alter); j++) {
	  // For each branch j.
	  if (size(modcgs_alter[j][3]) > 0) {
	    for (k = 1; k <= size(modcgs_alter[j][3]); k++) {
	      // For each g in G_j.
	      poly p = modcgs_alter[j][3][k][1] + modcgs_alter[j][3][k][2];
	      if (cur_poly == p) {
	        temp_mark = insert(temp_mark, j, size(temp_mark));
	      }
	    } // End for k.
	  }
	} // End for j.
      }
      Mark = insert(Mark, temp_mark, size(Mark));
    } // End for i.
  }

  // Remove redundant polys from mccgb_alter.
  int i, j;
  if (size(modcgs_alter) > 0) {
    for (i = 1; i <= size(modcgs_alter); i++) {
      // For each branch.
      if (size(modcgs_alter[i][3]) > 0) {
	for (j = 1; j <= size(modcgs_alter[i][3]); j++) {
	  // For each poly in G_i.
	  poly g = modcgs_alter[i][3][j][1] + modcgs_alter[i][3][j][2];
	  poly g1 = modcgs_alter[i][3][j][1];
	  // Get the index of g (or multiple of g) in mccgb_alter.
	  int idx_g = search_in_list(g, mccgb_alter, 1);
	  // Get LPP_X(sigma(mccgb_alter \ {g})).
	  list l = delete(mccgb_alter, idx_g);
	  vector lpp_basis = listToVec(calculateSigmaLPPList(l, modcgs_alter[i][1], modcgs_alter[i][2]));
	  ideal H = groebner(ideal(lpp_basis));
	  if (reduce(lpp_X(g1), H) == 0) {
	    // g is redundant in Branch i.
	    int del_idx = search_in_list(i, Mark[idx_g], 0);
	    Mark[idx_g] = delete(Mark[idx_g], del_idx);
	  }
	}
      }
    }
  }

  if (size(Mark) > 0) {
    int i;
    for (i = size(Mark); i >= 1; i--) {
      // If Mark[i] is empty, remove mccgb_alter[i] from mccgb_alter.
      if (size(Mark[i]) == 0) {
	mccgb_alter = delete(mccgb_alter, i);
      }
    }
  }

  // Switch back to @R.
  setring(BR);
  def mccgb_alter = imap(@RP, mccgb_alter);
  def G_alter = imap(@RP, G_alter);
  def modcgs_alter = imap(@RP, modcgs_alter);

  return (mccgb_alter, G_alter, modcgs_alter);
}

proc search_in_list(poly p, list basis, int multiple_flag) {
  // Base ring is Q[A][X].
  if (size(basis) == 0) {
    return (0);
  }

  int i;
  for (i = 1; i <= size(basis); i++) {
    if (multiple_flag) {
      // Either p or multiple of p occurs.
      ideal I = basis[i];
      if (reduce(p, I) == 0) {
	return (i);
      }
    } else {
      // p occurs.
      if (p == basis[i]) {
	return (i);
      }
    }
  }

  return (0);
}
