LIB "poly.lib";
LIB "primdec.lib";
LIB "qhmoduli.lib";
LIB "teachstd.lib";

LIB "../CGB/cgb_mod.lib";

// KEEP IT
proc set_global_rings_mccgb() {
  // Basering is R[U][X].
  def BR = basering;
  def @R = basering;

  def Rx = ringlist(BR);
  def @P = ring(Rx[1]);

  Rx[1] = 0;
  def D = ring(Rx);
  def @RP = D + @P;
  show(@RP);

  exportto(Top, @R);
  exportto(Top, @P);
  exportto(Top, @RP);
  setring(BR);
	
}
	
// KEEP IT
proc leadcoef_X(poly P) {
  int flag = 0;
  if (nameof(basering) != "@R") {
    def BR = basering;
    setring(@R);
    flag = 1;
    def P = imap(BR, P);
  }

  poly c = leadcoef(P);

  if (flag) {
    setring(BR);
    def c = imap(@R, c);
  }

  return (c);
}

// KEEP IT
proc lpp_X(poly P) {
  int flag = 0;

    if (nameof(basering) != "@R") {
      def BR = basering;
      setring(@R);
      flag = 1;
      def P = imap(BR, P);
    }

    def m = leadmonom(P);

    if (flag) {
      setring(BR);
      def m = imap(@R, m);
    }

    return (m);
}

// KEEP IT
proc lm_X(poly P) {
  int flag = 0;
  if (nameof(basering) != "@R") {
    def BR = basering;
    setring(@R);
    flag = 1;
    def P = imap(BR, P);
  }

  def T = lead(P);

  if (flag) {
    setring(BR);
    def T = imap(@R, T);
  }

  return (T);
}

// KEEP IT
proc listDeleteByPoly(list l, poly f) {
  int i;
  if (size(l) == 0) {
    return (list());
  } else {
    for (i = 1; i <= size(l); i++) {
      if (l[i] == f || l[i] == -f) {
	return (delete(l, i));
      }
    }
    return (l);
  }
}

// KEEP IT
proc appearInBranch(poly f, list branch) {
  // Basering is @RP.
  if (size(branch[3]) == 0) {
    return (0);
  } else {
    int i;
    for (i = 1; i <= size(branch[3]); i++) {
      poly g = branch[3][i][1] + branch[3][i][2];
      if (g == f || g == -f) {
	return (1);
      } else {
	// Check whether g = h * f, 
	// where h is in k[U].
	//poly quotient = g / f;
	//poly remainder = g - g/f * f;
	//if (lpp_X(quotient) == 1 && remainder == 0) {
	//return (1);
	//}
      }
    }
    return (0);
  }
}

// KEEP IT.
proc checkCoefZero(poly c, ideal E) {
  // Basering is @RP.
  ideal GE = radical(E);
  
  poly rem = reduce(c, GE);
  if (rem == 0) {
    return (1);
  } else {
    return (0);
  }

  
}

// KEEP IT
proc getCoefOfPP(poly pp, poly f) {
  // Basering is @RP.
  poly c;
  while (f != 0) {
    if (lpp_X(f) == pp) {
      c = leadcoef_X(f);
      break;
    } else {
      f = f - lm_X(f);
    }
  }

  return (c);
}

// KEEP IT
proc listContains(poly f, list l) {
  if (size(l) == 0) {
    return (0);
  } else {
    int i;
    for (i = 1; i <= size(l); i++) {
      if (f == l[i] || -f == l[i]) {
	return (1);
      }
    }
    return (0);
  }
}

// KEEP IT
proc genCandidateFaithfulPolys(poly lpp_f, list G, ideal E, list N) {
  // Basering is @RP.
  if (size(G) == 0) {
    return (list());
  }

  int i;
  list res_list;
  for (i = 1; i <= size(G); i++) {
    poly c = getCoefOfPP(lpp_f, G[i]);
    if (!checkCoefZero(c, E)) {
      res_list = insert(res_list, G[i], size(res_list));
    }
  }

  return (res_list);
}

// KEEP IT
proc ideal_exclude(ideal I, ideal J) {
  // Basering is @RP.
  if (size(I) == 0) {
    return (ideal());
  }

  if (size(J) == 0) {
    return (I);
  }
  
  poly prod_J = 1;
  int i, j;
  for (i = 1; i <= size(J); i++) {
    prod_J = prod_J * J[i];
  }
  ideal FL_J = factorize(prod_J, 1);

  for (i = 1; i <= size(I); i++) {
    for (j = 1; j <= size(FL_J); j++) {
      if (reduce(I[i], groebner(ideal(FL_J[j]))) == 0) {
	I[i] = I[i] / FL_J[j];
      }
    }
  }

  return (radical(I));
}

// KEEP IT
proc getNSquareFreeFromProd(poly h) {
  // Basering is @RP.
  ideal FL = factorize(h, 1);
  int i;
  list res_list;
  for (i = 1; i <= size(FL); i++) {
    res_list = insert(res_list, FL[i], size(res_list));
  }

  return (res_list);
}

// KEEP IT
proc redRepN(ideal E, list N, poly f) 
"
E, N are in red-representation.
If (E, N) is inconsistent, then E == ideal(1).
"
{
  // Basering is @RP.
  //ideal E1 = radical(E + ideal(f));
  ideal E1 = radical(E + ideal(f));

  poly h = 1;
  if (size(N) > 0) {
    int i;
    for (i = 1; i <= size(N); i++) {
      h = h * N[i];
    }
  }
  ideal res_E = ideal_exclude(E1, ideal(h));

  return (res_E, N);
}

// KEEP IT
proc redRepNN(ideal E, list N, poly f) 
"
E, N are in red-representation.
If (E, N) is inconsistent, then N == list().
"
{
  // Basering is @RP.
  int i;
  
  poly N_prod = 1;
  if (size(N) > 0) {
    for (i = 1; i <= size(N); i++) {
      N_prod = N_prod * N[i];
    }
  }
  poly h1 = reduce(N_prod * f, E);
  ideal newE = ideal_exclude(E, groebner(ideal(h1)));
  list newN = getNSquareFreeFromProd(h1);

  return (newE, newN);
}

// KEEP IT
proc splitBranch(ideal E, list N, poly f) 
"
E, N are in red-representation.
"
{
  // Basering is @RP.
  list res_list;

  ideal E0;
  list N0;
  (E0, N0) = redRepN(E, N, f);
  list sub1 = E0, N0;
  res_list = insert(res_list, sub1, size(res_list));
  if (groebner(E0)[1] == 1) {
    // (E0, N0) is inconsistent.
    list sub2 = E, N;
    res_list = insert(res_list, sub2, size(res_list));
  } else {
    ideal E1;
    list N1;
    (E1, N1) = redRepNN(E, N, f);
    list sub2 = E1, N1;
    res_list = insert(res_list, sub2, size(res_list));
  }

  return (res_list);
}

// KEEP IT.
proc checkNonNull(poly f, ideal E, list N) {
  // Basering is @RP.
  ideal E_red;
  list N_red;
  (E_red, N_red) = makeRedRepresentation(E, N);

  list sub_branches = splitBranch(E_red, N_red, f);
  if (sub_branches[1][1] == 1) {
    return (1);
  }

  return (0);
}

// KEEP IT
proc makeRedRepresentation(ideal E, list N) {
  // Basering is @RP.
  int i;
  ideal newE;
  list newN;

  // E is trivial.
  if (size(E) == 0) {
    if (size(N) == 0) {
      // N is also trivial.
      return (ideal(), list(1));
    } else {
      // N is not trivial.
      newE = ideal();
    }
  }
  
  // N is trivial.
  if (size(N) == 0) {
    newN = 1;
  }

  // E is not trivial.
  if (size(E) > 0) {
    newE = radical(E);
  }

  // N is not trivial.
  if (size(N) > 0) {
    poly prod_N = 1;
    for (i = 1; i <= size(N); i++) {
      prod_N = prod_N * N[i];
    }

    poly prod_N_rem = reduce(prod_N, newE);

    ideal FL_N = factorize(prod_N_rem, 1);

    list newN;
    for (i = 1; i <= size(FL_N); i++) {
      newN = insert(newN, FL_N[i], size(newN));
    }
  }

  return (newE, newN);
}

// KEEP IT
proc checkNullRedRep(ideal E, list N, poly f) 
"
E, N are in red-representation.
"
{
  // Basering is @RP.
  if (reduce(f, groebner(E)) == 0) {
    return (1);
  }

  return (0);
}

// KEEP IT
proc checkNonNullRedRep(ideal E, list N, poly f)
"
E, N are in red-representation.
"
{
  // Basering is @RP.
  ideal newE;
  list newN;
  (newE, newN) = redRepN(E, N, f);
  if (groebner(newE)[1] == 1) {
    return (1);
  }

  return (0);
}

// KEEP IT
proc getHigherCoefs(poly f, poly t) {
  // Basering is @RP.
  list res_list;
  while (lpp_X(f) > t) {
    res_list = insert(res_list, leadcoef_X(f), size(res_list));
    f = f - lm_X(f);
  }

  return (res_list);
}

// KEEP IT
proc checkEssentialInBranch(poly t, list G, ideal E, list N, link out) {
  // Basering is @RP.
  int i;
  fprintf(out, "-----------------------------------");
  fprintf(out, "Now come to Branch (<%s>, Pi{%s}):", string(E), string(N));


  // t is the LPP_X(g) currently used.
  list candidates = genCandidateFaithfulPolys(t, G, E, N);
  
  if (size(candidates) == 0) {
    fprintf(out, "There is no candidate poly.");
    return (1);
  }

  // Transform E and N into red-representation.
  ideal E_red;
  list N_red;
  (E_red, N_red) = makeRedRepresentation(E, N);
  fprintf(out, "Red-presentation of (E, N) is:");
  fprintf(out, "<%s>, Pi{%s}.", string(E_red), string(N_red));
  fprintf(out, "Candidate list is [");
  show_list_to_file(candidates, out);
  fprintf(out, "].");

  poly f = candidates[1];
  list raw_higher_coefs = getHigherCoefs(f, t);
  
  // reduce each poly in raw_higher_coefs by E_red.
  list higher_coefs;
  if (size(raw_higher_coefs) > 0) {
    ideal GE_red = groebner(E_red);
    for (i = 1; i <= size(raw_higher_coefs); i++) {
      poly rem = reduce(raw_higher_coefs[i], GE_red);
      if (rem != 0) {
	higher_coefs = insert(higher_coefs, rem, size(higher_coefs));
      }
    }
  }

  // Get coefficient of LPP t.
  poly ct = getCoefOfPP(t, f);
  
  list sub_branches = splitBranch(E_red, N_red, ct);
  ideal E0 = sub_branches[1][1];
  list N0 = sub_branches[1][2];
  ideal E1 = sub_branches[2][1];
  list N1 = sub_branches[2][2];

  fprintf(out, "Split (E, N) into two sub-branches wrt %s:", string(ct));
  fprintf(out, "Sub-branch 1: (<%s>, Pi{%s});", string(E0), string(N0));
  fprintf(out, "Sub-branch 2: (<%s>, Pi{%s}).", string(E1), string(N1));

  // Case I: ct is enforced to be 0.
  if (size(N1) == 0) {
    // Consider the rest candidates.
    fprintf(out, "coef_%s(%s) = %s is enforced to be 0", string(t), string(f), string(ct));
    return (checkEssentialInBranch(t, delete(G, 1), E0, N0, out))
  }

  // Case II: ct is enforced to be non-zero.
  if (groebner(E0)[1] == 1) {
    fprintf(out, "coef_%s(%s) = %s is enforced to be non-zero.", string(t), string(f), string(ct));

    if (size(higher_coefs) == 0) {
      fprintf(out, "And there is no non-zero higher term. g is covered by %s in Branch (<%s>, {%s}).", string(f), string(E1), string(N1));
      return (0);
    } else {
      fprintf(out, "But there are some non-zero higher terms in f.");
      list G_rem = listDeleteByPoly(G, f);
      ideal E_rem = E1;
      list N_rem = N1;
      ideal E_cur;
      list N_cur;
      // Consider each coefficient of higher terms.
      for (i = 1; i <= size(higher_coefs); i++) {
	// Split further only if the coef is not enforced.
	if (checkNonNull(higher_coefs[i], E_rem, N_rem) != 0) {
	  // higher_coefs[i] is enforced to be non-zero.
	  fprintf(out, "%s is enforced to be non-zero.", string(higher_coefs[i]));
	  if (checkEssentialInBranch(t, G_rem, E_rem, N_rem, out)) {
	    fprintf(out, "Thus, g is essential in Branch (<%s>, Pi{%s}).", string(E_rem), string(N_rem));
	    return (1);
	  } else {
	    fprintf(out, "g is covered in Branch (<%s>, Pi{%s}).", string(E_rem), string(N_rem));
	    return (0);
	  }
	} else {
	  fprintf(out, "%s is either zero or not.", string(higher_coefs[i]));
	}
	
	sub_branches = splitBranch(E_rem, N_rem, higher_coefs[i]);
	fprintf(out, "Split (<%s>, Pi{%s}) wrt %s:", string(E_rem), string(N_rem), string(higher_coefs[i]));
	E_rem = sub_branches[1][1];
	N_rem = sub_branches[1][2];
	E_cur = sub_branches[2][1];
	N_cur = sub_branches[2][2];
	fprintf(out, "Sub-branch 1: (<%s>, Pi{%s});", string(E_rem), string(N_rem));
	fprintf(out, "Sub-branch 2: (<%s>, Pi{%s}).", string(E_cur), string(N_cur));

	// For sub-branch in which higher_coefs[i] is non-zero.
	if (checkEssentialInBranch(t, G_rem, E_cur, N_cur, out)) {
	  fprintf(out, "g is essential in Sub-Branch (<%s>, Pi{%s}).", string(E_cur), string(N_cur));
	  fprintf(out, "Thus, g is essential in Branch (<%s>, Pi{%s}).", string(E1), string(N1));
	  return (1);
	} else {
	  fprintf(out, "g is covered in Sub-Branch (<%s>, Pi{%s}).", string(E_cur), string(N_cur));
	  // Consider the remaining sub-branch where higher_coefs[i] is zero.
	  continue;
	} // Endif.
      } // Endfor.
      
      fprintf(out, "Thus, g is non-essential in Branch (<%s>, Pi{%s}).", string(E1), string(N1));
      return (0);
    }
  }

  fprintf(out, "coef_%s(%s) = %s is either zero or not.", string(t), string(f), string(ct));
  // Case III: both sub-branches are consistent.
  if (size(higher_coefs) == 0) {
    // There is no higher monomial under specialization.
    fprintf(out, "There is no non-zero higher term in %s under (<%s>, Pi{%s}).", string(f), string(E_red), string(N_red));
    fprintf(out, "g is covered by %s in Sub-Branch 2: (<%s>, Pi{%s}).", string(f), string(E1), string(N1));
    fprintf(out, "We still need to check Sub-Branch 1.");
    return (checkEssentialInBranch(t, delete(G, 1), E0, N0, out));
  } else {
    fprintf(out, "But there are some non-zero higher terms in f.");
    // Consider (E1, N1).
    list G_rem = listDeleteByPoly(G, f);
    ideal E_rem = E1;
    list N_rem = N1;
    ideal E_cur;
    list N_cur;
    // Consider each coefficient of higher terms.
    for (i = 1; i <= size(higher_coefs); i++) {
      // Split further only if the coef is not enforced.
      poly nonnull = 1;
      int j;
      if (size(N_rem) > 0) {
	for (j = 1; j <= size(N_rem); j++) {
	  nonnull = nonnull * N_rem[j];
	}
      }
      if (checkNonNull(higher_coefs[i], E_rem, N_rem) != 0) {
	// higher_coefs[i] is enforced to be non-zero.
	fprintf(out, "%s is enforced to be non-zero.", string(higher_coefs[i]));
	if (checkEssentialInBranch(t, G_rem, E_rem, N_rem, out)) {
	  fprintf(out, "Thus, g is essential in Branch (<%s>, Pi{%s}).", string(E_rem), string(N_rem));
	  return (1);
	} else {
	  fprintf(out, "g is covered in Branch (<%s>, Pi{%s}).", string(E_rem), string(N_rem));
	  break;
	}
      } else {
	fprintf(out, "%s is either zero or not.", string(higher_coefs[i]));
      }

      fprintf(out, "Split (<%s>, Pi{%s}) wrt %s:", string(E_rem), string(N_rem), string(higher_coefs[i]));
      sub_branches = splitBranch(E_rem, N_rem, higher_coefs[i]);
      E_rem = sub_branches[1][1];
      N_rem = sub_branches[1][2];
      E_cur = sub_branches[2][1];
      N_cur = sub_branches[2][2];
      fprintf(out, "Sub-branch 1: (<%s>, Pi{%s});", string(E_rem), string(N_rem));
      fprintf(out, "Sub-branch 2: (<%s>, Pi{%s}).", string(E_cur), string(N_cur));
      

      // For sub-branch in which higher_coefs[i] is non-zero.
      if (checkEssentialInBranch(t, G_rem, E_cur, N_cur, out)) {
	fprintf(out, "g is essential in Sub-Branch (<%s>, Pi{%s}).", string(E_cur), string(N_cur));
	fprintf(out, "Thus, g is essential in Branch (<%s>, Pi{%s}).", string(E1), string(N1));
	return (1);
      } else {
	fprintf(out, "g is covered in Sub-Branch (<%s>, Pi{%s}).", string(E_cur), string(N_cur));
	// Consider the remaining sub-branch where higher_coefs[i] is zero.
	continue;
      } // Endif.
    } // Endfor.

    fprintf(out, "Thus, g is non-essential in Branch (<%s>, Pi{%s}).", string(E1), string(N1));

    // Now consider (E0, N0).
    fprintf(out, "But we still need to check Branch (<%s>, Pi{%s}).", string(E0), string(N0));
    if (checkEssentialInBranch(t, G_rem, E0, N0, out)) {
      fprintf(out, "g is essential in Sub-Branch (<%s>, Pi{%s}).", string(E0), string(N0));
      fprintf(out, "Thus, g is essential in Branch (<%s>, Pi{%s}).", string(E_red), string(N_red));
      return (1);
    } else {
      fprintf(out, "Thus, g is non-essential in Branch (<%s>, Pi{%s}).", string(E_red), string(N_red));
      return (0);
    }

  } // End of Case III.

}

proc get_nonzero_part(list l) {
    int i;
    list res_list;

    for (i = 1; i <= size(l); i++) {
	res_list[i] = l[i][1];
    }

    return (res_list);
}

// KEEP IT
// Used for top-down algorithm.
proc checkEssential(poly g, list G, list modcgs, link out) {
  // Basering is @RP.
  int i, j;
  
  if (size(modcgs) == 0) {
    fprintf(out, "CGS is empty!");
    return (1);
  }

  for (i = 1; i <= size(modcgs); i++) {
    // For each branch in which g appears.
    if (appearInBranch(g, modcgs[i])) {
      // G_i is guaranteed to be non-empty.

      // Compute nonnull_cond.
      poly nonnull_cond = 1;
      if (size(modcgs[i][2]) != 0) {
	for (j = 1; j <= size(modcgs[i][2]); j++) {
	  nonnull_cond = nonnull_cond * modcgs[i][2][j];
	}
      }

      fprintf(out, "**********************************");
      fprintf(out, "Come to Branch %s, in which g appears:", string(i));
      fprintf(out, "([%s],    [%s]).", string(modcgs[i][1]), string(modcgs[i][2]));

      fprintf(out, "sigma(G_%s) = [", string(i));
      show_list_to_file(get_nonzero_part(modcgs[i][3]), out);
      fprintf(out, "].");

      // Compute LPP_X(sigma(g)).
      poly lpp_g;
      for (j = 1; j <= size(modcgs[i][3]); j++) {
	if (g == modcgs[i][3][j][1] + modcgs[i][3][j][2]) {
	  lpp_g = lpp_X(modcgs[i][3][j][1]);
	}
      }
      fprintf(out, "LPP_X(sigma(%s)) = %s.", string(g), string(lpp_g));

      if (checkEssentialInBranch(lpp_g, listDeleteByPoly(G, g), modcgs[i][1], modcgs[i][2], out)) {
	fprintf(out, "%s is essential in Branch %s.", string(g), string(i));
	return (1);
      } else {
	fprintf(out, "%s is non-essential in Branch %s.", string(g), string(i));
      } // Endif.

    } // Endif.
  } // Endfor.
  
  // Now g is non-essential for all branches in which it appears.
  // Thus g is non-essential globally.
  return (0);
}

// KEEP IT
proc genMCCGB_topdown(ideal G, list modcgs, link out) {
  // Basering is @R.

  //(G, modcgs) = cgb_mod(Polys, Equ, DisEqu, out);
  set_global_rings_mccgb();

  // Switch to @RP.
  setring(@RP);
  def G = imap(@R, G);
  def modcgs = imap(@R, modcgs);

  fprintf(out, newline + "==========================");
  fprintf(out, "Now remove non-essential poly:");
  fprintf(out, "==========================");

  list mccgb;
  int i, j;

  // Initially, set G to be mccgb.
  for (i = 1; i <= size(G); i++) {
    mccgb[i] = G[i];
  }
  fprintf(out, "Initially, M = {");
  show_list_to_file(mccgb, out);
  fprintf(out, "}.");

  // For each poly in mccgb.
  for (i = 1; i <= size(G); i++) {
    poly cur_g = G[i];
    fprintf(out, newline + newline + "++++++++++++++++++++++++++++++++++");
    fprintf(out, "Now consider g = %s:", string(cur_g));
    mccgb = listDeleteByPoly(mccgb, cur_g);
    fprintf(out, "M' = {");
    show_list_to_file(mccgb, out);
    fprintf(out, "}.");
    
    if (checkEssential(cur_g, mccgb, modcgs, out)) {
      fprintf(out, "%s is essential.", string(cur_g));
      mccgb = insert(mccgb, cur_g, size(mccgb)); 
    } else {
      fprintf(out, "%s is not essential.", string(cur_g));
    }
  }

  // Switch back to @R.
  setring(@R);
  def mccgb = imap(@RP, mccgb);
  def G = imap(@RP, G);
  def modcgs = imap(@RP, modcgs);

  fprintf(out ,newline + "=================================");

  //return (mccgb, G, modcgs);
  return (mccgb);
     
}

// KEEP IT
proc showMCCGB(list mccgb, link out) {
    int i;

    fprintf(out, "M = [" + newline );
    if (size(mccgb) == 0) {
        fprintf(out, newline);
    } else {
	for (i = 1; i < size(mccgb); i++) {
	    fprintf(out, "%s,", mccgb[i]);
	}
	fprintf(out, "%s." + newline, mccgb[size(mccgb)]);
    }
    fprintf(out, "].");
}


// KEEP IT
proc show_list_to_file(list l, link out) {
  int i;
  if (size(l) == 0) {
    fprintf(out, newline);
  } else {
    for (i = 1; i <= size(l); i++) {
      fprintf(out, "        %s,", string(l[i]));
    }
  }
}

// KEEP IT
proc gen_indices_sub(int T, int Len) {
  int i, j;
  list res_list;
  if (Len == 1) {
    for (i = 1; i <= T; i++) {
      res_list = insert(res_list, list(i), size(res_list));
    }
    return (res_list);
  }

  list sub_list = gen_indices_sub(T, Len - 1);
  for (i = 1; i <= size(sub_list); i++) {
    list cur_sub_list = sub_list[i];
    int starting_point = cur_sub_list[size(cur_sub_list)] + 1;
   
    if (starting_point <= T){
      for (j = starting_point; j <= T; j++) {
	list l = cur_sub_list;
	l = insert(l, j, size(l));
	res_list = insert(res_list, l, size(res_list));
      }
    }
  }

  return (res_list);
}

// KEEP IT
proc gen_sub_list(list l) 
"USAGE:    Generate all the non-empty proper subsets of l.
RETURN:    A list of lists."
{
  int i, j;
  
  // Only generate the largest proper subsets.
  list index_list = gen_indices_sub(size(l), size(l) - 1);

  if (size(index_list) == 0) {
    return (list());
  }

  // General case.
  list sub_list;
  for (i = 1; i <= size(index_list); i++) {
    list cur_index_list = index_list[i];
    list res_list;
    for (j = 1; j <= size(cur_index_list); j++) {
      res_list = insert(res_list, l[cur_index_list[j]], size(res_list));
    }
    sub_list = insert(sub_list, res_list, size(sub_list));
  }

  return (sub_list);
}

// KEEP IT
proc list_diff(list L1, list L2) {
  if (size(L1) == 0) {
    return (list());
  }

  if (size(L2) == 0) {
    return (L1);
  }

  int i;
  list res;
  for (i = 1; i <= size(L1); i++) {
    if (!listContains(L1[i], L2)) {
      res = insert(res, L1[i], size(res));
    }
  }

  return (res);
}

// KEEP IT
proc check_comprehensive(list G, list M, list modcgs, string diff_basis, link out) {
  // Basering is @R.
  if (size(G) == 0) {
    fprintf(out, "G is empty.");
    return (1);
  }

  if (size(M) == 0) {
    fprintf(out, "M is empty.");
    return (0);
  }

  // General case:
  list check_list = list_diff(G, M);
  if (size(check_list) == 0) {
    fprintf(out, "G = M.");
    return (1);
  } else {
    int i, j;
    // For dumping.
    int dump_res = 1;
    // Switch to R[X, U].
    setring(@RP);
    def G = imap(@R, G);
    def M = imap(@R, M);
    def modcgs = imap(@R, modcgs);
    def check_list = imap(@R, check_list);
    poly g_tobechecked;

    fprintf(out, diff_basis);
    show_list_to_file(check_list, out);
    fprintf(out, "].");
    
    for (i = 1; i <= size(check_list); i++) {
      fprintf(out, newline + "++++++++++++++++++++++++++++");
      fprintf(out, "Now consider g = %s:", string(check_list[i]));
      g_tobechecked = check_list[i];
      if (checkEssential(g_tobechecked, M, modcgs, out)) {
	// g_tobechecked cannot be covered by any poly in M in some branch.
	// Switch back to R[U][X].
	setring(@R);
	//return (0);
	// For dumping.
	if (dump_res == 1) {
	  dump_res = 0;
	  fprintf(out, "Thus, g is essential for some branch it appears in.");
	} 
      } else {
	fprintf(out, "Thus, g is covered by some poly in M in all branches it appears in.");
      }
    } // Endfor.

    // All polys in check_list is non-essential.
    // Switch back to R[U][X].
    setring(@R);
    //return (1);
    // For dumping.
    return (dump_res);
  } // Endif.
}

// KEEP IT
proc check_minimal(list M, list modcgs, link out) 
"
Assume that M is already a CGB.
"
{
  // For dumping.
  int dump_res = 1;

  if (size(M) <= 1) {
    return (1);
  }

  list M_subs = gen_sub_list(M);

  int i, j;
  for (i = 1; i <= size(M_subs); i++) {
    // For each maximal proper subset of M.
    fprintf(out, newline + "$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$");
    fprintf(out, "%s. Now check M_sub[%s] = [", string(i), string(i));
    show_list_to_file(M_subs[i], out);
    fprintf(out, "    ]:");

    string diff_basis = "M - M_sub[" + string(i) + "] = [";

    if (check_comprehensive(M, M_subs[i], modcgs, diff_basis, out)) {
      // M_sub[i] is also a CGB, then M is not minimal.
      fprintf(out, "The subset M_sub[%s] is also a CGB of <F>.", string(i));
      //return (0);
      // For dumping.
      if (dump_res == 1) {dump_res = 0;}
    } else {
      fprintf(out, "The subset M_sub[%s] is not comprehensive.", string(i));
    }
  }
  // return (1);
  // For dumping.
  return (dump_res);
}

// KEEP IT
proc check_validity(ideal cgb, list mccgb, list modcgs, link out) {
  fprintf(out, newline + "============================");
  fprintf(out, "Now check whether M is comprehensive and minimal:");
  fprintf(out, "------------------");

  fprintf(out, "First, check the comprehensiveness of M:" + newline);

  list G;
  int i;
  if (size(cgb) > 0) {
    for (i = 1; i <= size(cgb); i++) {
      G = insert(G, cgb[i], size(G));
    }
  }

  string diff_basis = "G - M = [";

  if (check_comprehensive(G, mccgb, modcgs, diff_basis, out)) {
    // mccgb is comprehensive, then check the minimality.
    fprintf(out, newline + "M is comprehensive.");
    fprintf(out, newline + newline + "================================");
    fprintf(out, "Second, check the minimality of M:");
    if (check_minimal(mccgb, modcgs, out)) {
      // mccgb is also minimal.
      fprintf(out, newline + "M is minimal.");
      return ("", 1);
    } else {
      // mccgb is not minimal.
      fprintf(out, newline + "M is not minimal.");
      return ("it is not minimal", 0);
    }
  } else {
    // mccgb is not comprehensive.
    fprintf(out, newline + "M is not comprehensive.");
    return ("it is not comprehensive", 0);
  }
}

