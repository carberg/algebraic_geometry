LIB "grobcov.lib";
LIB "mcgb.lib";

proc show_list_to_file(list l, link out) {
  int i;
  if (size(l) == 0) {
    fprintf(out, newline);
  } else {
    for (i = 1; i <= size(l); i++) {
      fprintf(out, "        %s,", string(l[i]));
    }
  }
}

proc gen_largest_proper_sublists(list l)
"USAGE:    Generate all sublists of with size of size(l)-1
RETURN:    A list of such sublists."
{
  if (size(l) <= 1) {
    return (list());
  }

  list sub_lists;
  int i;
  for (i = 1; i <= size(l); i++) {
    list l_sub = delete(l, i);
    sub_lists = insert(sub_lists, l_sub, size(sub_lists));
  }

  return (sub_lists);
}

proc list_diff(list L1, list L2) {
  if (size(L1) == 0) {
    return (list());
  }

  if (size(L2) == 0) {
    return (L1);
  }

  int i;
  list res;
  for (i = 1; i <= size(L1); i++) {
    if (!listContains(L2, L1[i])) {
      res = insert(res, L1[i], size(res));
    }
  }

  return (res);
}

proc check_comprehensive(list M, list CGS) {
  // Basering is @R.
  if (size(CGS) == 0) {
    if (defined(debug_mode) && debug_mode == 1) {
      fprintf(out, "CGS is empty.");
    }
    return (1);
  }

  if (size(M) == 0) {
    if (defined(debug_mode) && debug_mode == 1) {
      fprintf(out, "M is empty.");
    }
    return (0);
  }

  // Switch to @RP.
  setring @RP;
  def M = imap(@R, M);
  def CGS = imap(@R, CGS);

  int i, j;
  for (i = 1; i <= size(CGS); i++) {
    if (size(CGS[i][3]) > 0) {
      for (j = 1; j <= size(CGS[i][3]); j++) {
	poly f = monic(CGS[i][3][j][1] + CGS[i][3][j][2]);

	if (!listContains(M, f)) {
	  poly pp_f = lppX(CGS[i][3][j][1]);
	  ideal E_cur = CGS[i][1];
	  list N_cur = CGS[i][2];
	  if (size(N_cur) == 0) {
	    N_cur = list(1);
	  }

	  list G_branch = CGS[i][3];
	  int is_essential;
	  list DontCare;
	  (is_essential, DontCare) = checkEssentialInBranch(f, pp_f, M, E_cur, N_cur, G_branch, DontCare);
	  if (is_essential) {
	    return (0);
	  }
	}
      } // End for.
    }
  } // End for.

  return (1);
}

proc check_minimal(list M, list CGS) {
  // Basering is @R.
  if (size(CGS) == 0) {
    if (defined(debug_mode) && debug_mode == 1) {
      fprintf(out, "CGS is empty.");
    }
    return (1);
  }

  if (size(M) == 0) {
    if (defined(debug_mode) && debug_mode == 1) {
      fprintf(out, "G is empty.");
    }
    return (0);
  }

  list M_subs = gen_largest_proper_sublists(M);

  int i, j;
  for (i = 1; i <= size(M_subs); i++) {
    // For each maximal proper subset of M.
    if (defined(debug_mode) && debug_mode == 1) {
      fprintf(out, newline + "$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$");
      fprintf(out, "%s. Now check M_sub[%s] = [", string(i), string(i));
      show_list_to_file(M_subs[i], out);
      fprintf(out, "    ]:");
    }

    if (check_comprehensive(M_subs[i], CGS)) {
      if (defined(debug_mode) && debug_mode == 1) {
	fprintf(out, "The subset M_sub[%s] is also a CGS of <F>.", string(i));
      }
      return (0);
    } else {
      if (defined(debug_mode) && debug_mode == 1) {
	fprintf(out, "The subset M_sub[%s] is not comprehensive.", string(i));
      }
    }
  } // End for.
  return (1);
}

proc check_validity(list M, list CGS) {
  // Basering is @R.
  if (defined(debug_mode) && debug_mode == 1) {
    fprintf(out, newline + "============================");
    fprintf(out, "Now check whether M is comprehensive and minimal:");
    fprintf(out, "------------------");

    fprintf(out, "First, check the comprehensiveness of M:" + newline);
  }

  if (check_comprehensive(M, CGS)) {
    // M is comprehensive, then check the minimality.
    if (defined(debug_mode) && debug_mode == 1) {
      fprintf(out, newline + "M is comprehensive.");
      fprintf(out, newline + newline + "================================");
      fprintf(out, "Second, check the minimality of M:");
    }
    if (check_minimal(M, CGS)) {
      // M is also minimal.
      if (defined(debug_mode) && debug_mode == 1) {
	fprintf(out, newline + "M is minimal.");
      }
      fprintf(out, "It is comprehensive and minimal.");
      return (1);
    } else {
      // M is not minimal.
      if (defined(debug_mode) && debug_mode == 1) {
	fprintf(out, newline + "M is not minimal.");
      }
      fprintf(out, "It is comprehensive, but not minimal.");
      return (-1);
    }
  } else {
    // M is not comprehensive.
    if (defined(debug_mode) && debug_mode == 1) {
      fprintf(out, newline + "M is not comprehensive.");
    }
    fprintf(out, "It is not comprehensive.");
    return (0);
  }
}

proc check_faithful(poly f, ideal I) {
  // Basering is @R.
    def BR = basering;
    setring @RP;
    def f = imap(BR, f);
    def I = imap(BR, I);
    if (reduce(f, groebner(I)) == 0) {
      return (1);
    } else {
      return (0);
    }

}

/*
The part of checking if a finite set of polynomilas is a CGB.
 */

proc termDivisible(poly p1, poly p2) {
  if (p2 / p1 == 0) {
    return (0);
  }

  return (1);
}

/*
proc quotientDivision(poly f, ideal I) {
  int ring_flag = 0;
  if (nameof(basering) != "@R") {
    def BR = basering;
    setring @R;
    def f = imap(BR, f);
    def I = imap(BR, I);
    ring_flag = 1;
  }

  if (size(I) == 0) {
    if (ring_flag) {
      setring BR;
    }
    return (0, list(), 0);
  }

  list quots;
  int i, j;
  
  for (i = 1; i <= size(I); i++) {
    quots = insert(quots, 0, size(quots));
  }
  poly rem = f;
  poly cur_quo;
  poly coeff_rem = 1;
  int reduced = 0;

  while (rem != 0) {
    reduced = 0;
    for (i = 1; i <= size(I); i++) {
      if (termDivisible(leadmonom(I[i]), leadmonom(rem))) {
	rem = rem * leadcoef(I[i]);
	coeff_rem = coeff_rem * leadcoef(I[i]);
	cur_quo = lead(rem) / lead(I[i]);
	rem = rem - cur_quo * I[i];

	// update quots.
	for (j = 1; j <= size(I); j++) {
	  quots[j] = quots[j] * leadcoef(I[i]);
	}
	quots[i] = quots[i] + cur_quo;
	reduced = 1;
	break;
      }

    }

    if (!reduced) {
      break;
    }
    
  }

  if (ring_flag) {
    setring BR;
    def coeff_rem = imap(@R, coeff_rem);
    if (!defined(quots)) {
      def quots = imap(@R, quots);
    }
    def rem = imap(@R, rem);
  }

  return (coeff_rem, quots, rem);
}
*/

proc pseudoDivi(poly f, ideal F) {
  int ring_flag = 0;
  if (nameof(basering) != "@R") {
    def BR = basering;
    setring @R;
    def f = imap(BR, f);
    def F = imap(BR, F);
    ring_flag = 1;
  }

  list L = pdivi(f, F);

  if (ring_flag) {
    setring BR;
    def L = imap(@R, L);
  }

  return (L);
}

proc getSPoly(poly f, poly g) {
  if (f == 0) {
    return (g);
  }

  if (g == 0) {
    return (f);
  }
  
  int ring_flag = 0;
  if (nameof(basering) != "@RP") {
    def BR = basering;
    setring @RP;
    def f = imap(BR, f);
    def g = imap(BR, g);
    ring_flag = 1;
  }

  poly teller = lcm(lm_X(f), lm_X(g));
  poly h = (teller / lm_X(f)) * f - (teller / lm_X(g)) * g;
  
  if (ring_flag) {
    setring BR;
    def h = imap(@RP, h);
  }

  return (h);
}

proc checkRemNull(poly f, ideal E, list N) {
  // basering is @RP.
  if (f == 0) {
    return (1);
  }

  while (f != 0) {
    poly c = leadcoef_U(f);
    if (!checkNull(c, E, N)) {
      return (0);
    } else {
      f = f - lm_X(f);
    }
  }

  return (1);
}

proc coprimeLPP(poly f, poly g) {
  if (f == 0 || g == 0) {
    return (1);
  }

  int ring_flag = 0;
  if (nameof(basering) != "@R") {
    def BR = basering;
    setring @R;
    def f = imap(BR, f);
    def g = imap(BR, g);
    ring_flag = 1;
  }

  if (lcm(leadmonom(f), leadmonom(g)) == leadmonom(f) * leadmonom(g)) {
    if (ring_flag) {
      setring BR;
    }
    return (1);
  } else {
    if (ring_flag) {
      setring BR;
    }
    return (0);
  }
}

proc showParamPoly(poly f) {
  if (f == 0) {
    return (string(0));
  }

  int ring_flag = 0;
  if (nameof(basering) != "@R") {
    def BR = basering;
    setring @R;
    def f = imap(BR, f);
    ring_flag = 1;
  }

  string f_str = string(f);

  if (ring_flag) {
    setring BR;
  }

  return (f_str);
}

proc numParamMonom(poly f) {
  if (f == 0) {
    return (0);
  }

  if (size(f) == 1) {
    return (1);
  }
  
  int ring_flag = 0;
  if (nameof(basering) != "@R") {
    def BR = basering;
    setring @R;
    def f = imap(BR, f);
    ring_flag = 1;
  }

  int res = size(f);

  if (ring_flag) {
    setring BR;
  }

  return (res);
}

// Set static after debugging.
proc checkPairRec(poly f, poly g, ideal G, ideal E, list N) {
  // basering is @RP.
  fprintf(special_out, "++++++++++++++++++");
  if (!Check_Consistence_CGB(E, N)) {
    fprintf(special_out, "E = <%s>,", string(E));
    fprintf(special_out, "N = {%s}.", string(N));    
    fprintf(special_out, newline + "Inconsistent branch!");
    
    return (1);
  }

  poly f_nz, f_z;
  (f_nz, f_z) = simplifyPoly(f, E);
  poly g_nz, g_z;
  (g_nz, g_z) = simplifyPoly(g, E);

  int computation_flag = 1;
  poly rem, m;
  ideal quots;
  int i;

  if (f_nz == 0 || g_nz == 0) {
    fprintf(special_out, "E = <%s>,", string(E));
    fprintf(special_out, "N = {%s}." + newline, string(N));
    
    fprintf(special_out, "σ(f) = %s.", showParamPoly(f_nz));
    fprintf(special_out, "σ(g) = %s." + newline, showParamPoly(g_nz));
    fprintf(special_out, "At least one poly is specialized to 0!");
    return (1);
  }

  if (numParamMonom(g_nz) == 1 && numParamMonom(f_nz) == 1) {
    fprintf(special_out, "E = <%s>,", string(E));
    fprintf(special_out, "N = {%s}." + newline, string(N));
    
    fprintf(special_out, "σ(f) = %s.", showParamPoly(f_nz));
    fprintf(special_out, "σ(g) = %s." + newline, showParamPoly(g_nz));
    fprintf(special_out, "Both are monomials!");
    return (1);
  }

  if (coprimeLPP(f_nz, g_nz)) {
    computation_flag = 0;
    rem = 0;
    m = 1;
  }

  list N_comp = N;

  if (f_nz != 0) {
    N_comp = insert(N_comp, leadcoef_U(f_nz), size(N_comp));
  }

  if (g_nz != 0) {
    N_comp = insert(N_comp, leadcoef_U(g_nz), size(N_comp));
  }
  
  
  if (computation_flag) {
    poly h = getSPoly(f_nz, g_nz);

    list L;
    list L_idx;
    for (i = 1; i <= size(G); i++) {
      poly p_nz, p_z;
      (p_nz, p_z) = simplifyPoly(G[i], E);
      if (p_nz != 0) {
	L = insert(L, p_nz, size(L));
	L_idx = insert(L_idx, i, size(L_idx));
      }
    }

    ideal G_nz = listToIdeal(L);

    list pd_struct = pseudoDivi(h, G_nz);
    rem = pd_struct[1];
    quots = pd_struct[2];
    m = pd_struct[3];

    N_comp = insert(N_comp, m, size(N_comp));

    string pdivi_res;
    pdivi_res = "(" + string(m) + ") " + "h = ";
    if (size(quots) == 1) {
      if (quots[1] != 0) {
	pdivi_res = pdivi_res + "(" + showParamPoly(quots[1]) + ") " + "σ(G[" + string(L_idx[1]) + "])";
      } else {
	pdivi_res = pdivi_res + "0";
      }
    } else {
      for (i = 1; i <= size(quots); i++) {
	if (quots[i] != 0) {
	  pdivi_res = pdivi_res + "(" + showParamPoly(quots[i]) + ") " + "σ(G[" + string(L_idx[i]) + "]) + ";
	}
      }
    }
    
    pdivi_res = pdivi_res + " + " + showParamPoly(rem) + ".";

  }

  
  if (rem != 0) {
    if (!checkRemNull(rem, E, N_comp)) {
          fprintf(special_out, "E = <%s>,", string(E));
	  fprintf(special_out, "N = {%s}.", string(N_comp));
	  fprintf(special_out, newline + "σ(f) = %s.", showParamPoly(f_nz));
	  fprintf(special_out, "σ(g) = %s.", showParamPoly(g_nz));
	  fprintf(special_out, newline + "h = S-Poly(σ(f), σ(g)) = %s.", showParamPoly(h));
    
	  fprintf(special_out, "σ(G) = {");
    
	  for (i = 1; i <= size(G_nz); i++) {
	    fprintf(special_out, "    σ(G[%s]) = %s,", string(L_idx[i]), G_nz[i]);
	  }
    
	  fprintf(special_out, "}." + newline);
	  
	  fprintf(special_out, "Pseudo-Division:");
	  fprintf(special_out, "    %s.", pdivi_res);
    
	  fprintf(special_out, newline + "Remainder %s not specialized to 0.", string(rem));
					
	  return (0);
    }
  }

  
  ideal N_comp_factors = getFactorIdeal(N_comp);

  if (!computation_flag) {
    fprintf(special_out, "E = <%s>,", string(E));
    fprintf(special_out, "N = {%s}." + newline, string(N_comp_factors));
    
    fprintf(special_out, "σ(f) = %s.", showParamPoly(f_nz));
    fprintf(special_out, "σ(g) = %s." + newline, showParamPoly(g_nz));  

    fprintf(special_out, "Co-Prime!");
  }
  
  if (computation_flag) {
    fprintf(special_out, "E = <%s>,", string(E));
    fprintf(special_out, "N = {%s}.", string(N_comp_factors));
    fprintf(special_out, newline + "σ(f) = %s.", showParamPoly(f_nz));
    fprintf(special_out, "σ(g) = %s.", showParamPoly(g_nz));
    fprintf(special_out, newline + "h = S-Poly(σ(f), σ(g)) = %s.", showParamPoly(h));
    
    fprintf(special_out, "σ(G) = {");
    
    for (i = 1; i <= size(G_nz); i++) {
      fprintf(special_out, "    σ(G[%s]) = %s,", string(L_idx[i]), showParamPoly(G_nz[i]));
    }
    
    fprintf(special_out, "}." + newline);
    
    fprintf(special_out, "Pseudo-Division:");
    fprintf(special_out, "    %s.", pdivi_res);

    fprintf(special_out, newline + "Remainder specialized to 0!");
  }

  poly factor_used = 1;
  for (i = 1; i <= size(N_comp_factors); i++) {
    ideal E_next = paramIdealInsert(E, N_comp_factors[i]);
    fprintf(special_out, newline + "Next, Add %s to E;", string(N_comp_factors[i]));
    list N_next = insert(N, factor_used, size(N));
    fprintf(special_out, "Add %s to N.", string(factor_used));
    factor_used = factor_used * N_comp_factors[i];
    if (!checkPairRec(f, g, G, E_next, N_next)) {
      return (0);
    }
  }
  
  return (1);

}

// Set static after debugging.
proc checkPair(poly f, poly g, ideal G) {
  if (size(f) <= 1 && size(g) <= 1) {
    return (1);
  }
  
  int ring_flag = 0;
  if (nameof(basering) != "@RP") {
    def BR = basering;
    setring @RP;
    def f = imap(BR, f);
    def g = imap(BR, g);
    def G = imap(BR, G);
    ring_flag = 1;
  }
  
  ideal E = 0;
  list N = 1;
  if (checkPairRec(f, g, G, E, N)) {
    if (ring_flag) {
      setring BR;
    }
    
    return (1);
  }

  if (ring_flag) {
    setring BR;
  }

  return (0);
}

proc checkCGBness(ideal G) {
  if (size(G) <= 1) {
    return (1);
  }

  int ring_flag = 0;
  if (nameof(basering) != "@R") {
    def BR = basering;
    setring @R;
    def G = imap(BR, G);
    ring_flag = 1;
  }
  
  int i, j;
  
  fprintf(special_out, "G = {");
  for (i = 1; i <= size(G); i++) {
    fprintf(special_out, "G[%s] = %s,", string(i), string(G[i]));
  }
  fprintf(special_out, "}." + newline);
  
  for (i = 1; i < size(G); i++) {
    for (j = i + 1; j <= size(G); j++) {
      fprintf(special_out, newline + newline + "---------------------------");
      fprintf(special_out, "Consider f = G[%s] (has %s monomials) and g = G[%s] (has %s monomials):", string(i), string(size(G[i])), string(j), string(size(G[j])));
      printf("Consider G[%s] (of size %s) and G[%s] (of size %s):", string(i), string(size(G[i])), string(j), string(size(G[j])));
      if (!checkPair(G[i], G[j], G)) {
	if (ring_flag) {
	  setring BR;
	}
        return (0);
      }
    }
  }

  if (ring_flag) {
    setring BR;
  }
  return (1);
}
