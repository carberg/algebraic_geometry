LIB "mcgb.lib";

proc show_list_to_file(list l, link out) {
  int i;
  if (size(l) == 0) {
    fprintf(out, newline);
  } else {
    for (i = 1; i <= size(l); i++) {
      fprintf(out, "        %s,", string(l[i]));
    }
  }
}

proc gen_largest_proper_sublists(list l)
"USAGE:    Generate all sublists of with size of size(l)-1
RETURN:    A list of such sublists."
{
  if (size(l) <= 1) {
    return (list());
  }

  list sub_lists;
  int i;
  for (i = 1; i <= size(l); i++) {
    list l_sub = delete(l, i);
    sub_lists = insert(sub_lists, l_sub, size(sub_lists));
  }

  return (sub_lists);
}

proc list_diff(list L1, list L2) {
  if (size(L1) == 0) {
    return (list());
  }

  if (size(L2) == 0) {
    return (L1);
  }

  int i;
  list res;
  for (i = 1; i <= size(L1); i++) {
    if (!listContains(L2, L1[i])) {
      res = insert(res, L1[i], size(res));
    }
  }

  return (res);
}

proc check_comprehensive(list M, list CGS) {
  // Basering is @R.
  if (size(CGS) == 0) {
    if (defined(debug_mode) && debug_mode == 1) {
      fprintf(out, "CGS is empty.");
    }
    return (1);
  }

  if (size(M) == 0) {
    if (defined(debug_mode) && debug_mode == 1) {
      fprintf(out, "M is empty.");
    }
    return (0);
  }

  // Switch to @RP.
  setring @RP;
  def M = imap(@R, M);
  def CGS = imap(@R, CGS);

  int i, j;
  for (i = 1; i <= size(CGS); i++) {
    if (size(CGS[i][3]) > 0) {
      for (j = 1; j <= size(CGS[i][3]); j++) {
	poly f = monic(CGS[i][3][j][1] + CGS[i][3][j][2]);

	if (!listContains(M, f)) {
	  poly pp_f = lppX(CGS[i][3][j][1]);
	  ideal E_cur = CGS[i][1];
	  list N_cur = CGS[i][2];
	  if (size(N_cur) == 0) {
	    N_cur = list(1);
	  }

	  list G_branch = CGS[i][3];
	  int is_essential;
	  list DontCare;
	  (is_essential, DontCare) = checkEssentialInBranch(f, pp_f, M, E_cur, N_cur, G_branch, DontCare);
	  if (is_essential) {
	    return (0);
	  }
	}
      } // End for.
    }
  } // End for.

  return (1);
}

proc check_minimal(list M, list CGS) {
  // Basering is @R.
  if (size(CGS) == 0) {
    if (defined(debug_mode) && debug_mode == 1) {
      fprintf(out, "CGS is empty.");
    }
    return (1);
  }

  if (size(M) == 0) {
    if (defined(debug_mode) && debug_mode == 1) {
      fprintf(out, "G is empty.");
    }
    return (0);
  }

  list M_subs = gen_largest_proper_sublists(M);

  int i, j;
  for (i = 1; i <= size(M_subs); i++) {
    // For each maximal proper subset of M.
    if (defined(debug_mode) && debug_mode == 1) {
      fprintf(out, newline + "$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$");
      fprintf(out, "%s. Now check M_sub[%s] = [", string(i), string(i));
      show_list_to_file(M_subs[i], out);
      fprintf(out, "    ]:");
    }

    if (check_comprehensive(M_subs[i], CGS)) {
      if (defined(debug_mode) && debug_mode == 1) {
	fprintf(out, "The subset M_sub[%s] is also a CGS of <F>.", string(i));
      }
      return (0);
    } else {
      if (defined(debug_mode) && debug_mode == 1) {
	fprintf(out, "The subset M_sub[%s] is not comprehensive.", string(i));
      }
    }
  } // End for.
  return (1);
}

proc check_validity(list M, list CGS) {
  // Basering is @R.
  if (defined(debug_mode) && debug_mode == 1) {
    fprintf(out, newline + "============================");
    fprintf(out, "Now check whether M is comprehensive and minimal:");
    fprintf(out, "------------------");

    fprintf(out, "First, check the comprehensiveness of M:" + newline);
  }

  if (check_comprehensive(M, CGS)) {
    // M is comprehensive, then check the minimality.
    if (defined(debug_mode) && debug_mode == 1) {
      fprintf(out, newline + "M is comprehensive.");
      fprintf(out, newline + newline + "================================");
      fprintf(out, "Second, check the minimality of M:");
    }
    if (check_minimal(M, CGS)) {
      // M is also minimal.
      if (defined(debug_mode) && debug_mode == 1) {
	fprintf(out, newline + "M is minimal.");
      }
      fprintf(out, "It is comprehensive and minimal.");
      return (1);
    } else {
      // M is not minimal.
      if (defined(debug_mode) && debug_mode == 1) {
	fprintf(out, newline + "M is not minimal.");
      }
      fprintf(out, "It is comprehensive, but not minimal.");
      return (-1);
    }
  } else {
    // M is not comprehensive.
    if (defined(debug_mode) && debug_mode == 1) {
      fprintf(out, newline + "M is not comprehensive.");
    }
    fprintf(out, "It is not comprehensive.");
    return (0);
  }
}

proc check_faithful(poly f, ideal I) {
  // Basering is @R.
    def BR = basering;
    setring @RP;
    def f = imap(BR, f);
    def I = imap(BR, I);
    if (reduce(f, groebner(I)) == 0) {
      return (1);
    } else {
      return (0);
    }

}

/*
The part of checking if a finite set of polynomilas is a CGB.
 */

proc termDivisible(poly p1, poly p2) {
  if (p2 / p1 == 0) {
    return (0);
  }

  return (1);
}

proc quotientDivision(poly f, ideal I) {
  int ring_flag = 0;
  if (nameof(basering) != "@R") {
    def BR = basering;
    setring @R;
    def f = imap(BR, f);
    def I = imap(BR, I);
    ring_flag = 1;
  }

  if (size(I) == 0) {
    if (ring_flag) {
      setring BR;
    }
    return (0, list(), 0);
  }

  list quots;
  int i, j;
  
  for (i = 1; i <= size(I); i++) {
    quots = insert(quots, 0, size(quots));
  }
  poly rem = f;
  poly cur_quo;
  poly coeff_rem = 1;
  int reduced = 0;

  while (rem > 0) {
    reduced = 0;
    for (i = 1; i <= size(I); i++) {
      if (termDivisible(leadmonom(I[i]), leadmonom(rem))) {
	rem = rem * leadcoef(I[i]);
	coeff_rem = coeff_rem * leadcoef(I[i]);
	cur_quo = lead(rem) / lead(I[i]);
	rem = rem - cur_quo * I[i];

	// update quots.
	for (j = 1; j <= size(I); j++) {
	  quots[j] = quots[j] * leadcoef(I[i]);
	}
	quots[i] = quots[i] + cur_quo;
	reduced = 1;
	break;
      }

    }

    if (!reduced) {
      break;
    }
    
  }

  if (ring_flag) {
    setring BR;
    def coeff_rem = imap(@R, coeff_rem);
    def quots = imap(@R, quots);
    def rem = imap(@R, rem);
  }

  return (coeff_rem, quots, rem);
}

static proc getSPoly(poly f, poly g) {
  int ring_flag = 0;
  if (nameof(basering) != "@RP") {
    def BR = basering;
    setring @RP;
    def f = imap(BR, f);
    def g = imap(BR, g);
    ring_flag = 1;
  }

  poly h;
  // Yiming: need to be finished.
  
  if (ring_flag) {
    setring BR;
    def h = imap(@RP, h);
  }

  return (h);
}

static proc checkPairRec(poly f, poly g, ideal G, ideal E, list N) {
  if (!Check_Consistence_CGB(E, N)) {
    return (1);
  }

  list L;
  int i;
  for (i = 1; i <= size(G); i++) {
    poly p_nz, p_z;
    (p_nz, p_z) = simplifyPoly(G[i], E);
    if (p_nz != 0) {
      L = insert(L, p_nz, size(L));
    }
  }

  ideal G_nz = listToIdeal(L);

  // Reduce S-Poly(f, g) in (E, N).
  poly h = getSPoly(f, g);
  poly m, rem;
  list quots;
  (m, quots, rem) = quotientDivision(h, G_nz);
  if (rem != 0) {
    if (!checkRemNull(rem, E, N)) {
      return (0);
    }
  }
  ideal N_comp = insert(N, m, size(N));
  ideal N_comp_factors = getFactorIdeal(N_comp);

  if (size(N_comp_factors) == 1) {
    E = paramIdealInsert(E, N_comp_factors[1]);
    return (checkPairRec(f, g, G, E, N));
  } else {
    poly factor_used = 1;
    for (i = 1; i <= size(N_comp_factors); i++) {
      ideal E_next = paramIdealInsert(E, N_comp_factors[i]);
      list N_next = insert(N, factor_used, size(N));
      factor_used = factor_used * N_comp_factors[i];
      if (!checkPairRec(f, g, G, E_next, N_next)) {
	return (0);
      }
    }
    return (1);
  }
  
}

static proc checkPair(poly f, poly g, ideal G) {
  ideal E = 0;
  list N = 1;
  if (checkPairRec(f, g, G, E, N)) {
    return (1);
  }

  return (0);
}

proc checkCGBness(ideal G) {
  if (size(G) <= 1) {
    return (1);
  }

  int ring_flag = 0;
  if (nameof(basering) != "@R") {
    def BR = basering;
    setring @R;
    def G = imap(BR, G);
    ring_flag = 1;
  }

  int i, j;
  for (i = 1; i < size(G); i++) {
    for (j = i + 1; j <= size(G); j++) {
      if (!checkPair(G[i], G[j], G)) {
	if (ring_flag) {
	  setring BR;
	}
        return (0);
      }
    }
  }

  if (ring_flag) {
    setring BR;
  }
  return (1);
}
