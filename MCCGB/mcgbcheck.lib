LIB "mcgb.lib";

proc listContains(poly f, list l) {
  if (size(l) == 0) {
    return (0);
  } else {
    int i;
    for (i = 1; i <= size(l); i++) {
      if (f == l[i] || -f == l[i]) {
	return (1);
      }
    }
    return (0);
  }
}

proc show_list_to_file(list l, link out) {
  int i;
  if (size(l) == 0) {
    fprintf(out, newline);
  } else {
    for (i = 1; i <= size(l); i++) {
      fprintf(out, "        %s,", string(l[i]));
    }
  }
}

proc gen_indices_sub(int T, int Len) {
  int i, j;
  list res_list;
  if (Len == 1) {
    for (i = 1; i <= T; i++) {
      res_list = insert(res_list, list(i), size(res_list));
    }
    return (res_list);
  }

  list sub_list = gen_indices_sub(T, Len - 1);
  for (i = 1; i <= size(sub_list); i++) {
    list cur_sub_list = sub_list[i];
    int starting_point = cur_sub_list[size(cur_sub_list)] + 1;
   
    if (starting_point <= T){
      for (j = starting_point; j <= T; j++) {
	list l = cur_sub_list;
	l = insert(l, j, size(l));
	res_list = insert(res_list, l, size(res_list));
      }
    }
  }

  return (res_list);
}

proc gen_sub_list(list l) 
"USAGE:    Generate all the non-empty proper subsets of l.
RETURN:    A list of lists."
{
  int i, j;
  
  // Only generate the largest proper subsets.
  list index_list = gen_indices_sub(size(l), size(l) - 1);

  if (size(index_list) == 0) {
    return (list());
  }

  // General case.
  list sub_list;
  for (i = 1; i <= size(index_list); i++) {
    list cur_index_list = index_list[i];
    list res_list;
    for (j = 1; j <= size(cur_index_list); j++) {
      res_list = insert(res_list, l[cur_index_list[j]], size(res_list));
    }
    sub_list = insert(sub_list, res_list, size(sub_list));
  }

  return (sub_list);
}

proc list_diff(list L1, list L2) {
  if (size(L1) == 0) {
    return (list());
  }

  if (size(L2) == 0) {
    return (L1);
  }

  int i;
  list res;
  for (i = 1; i <= size(L1); i++) {
    if (!listContains(L1[i], L2)) {
      res = insert(res, L1[i], size(res));
    }
  }

  return (res);
}

proc check_comprehensive(list M, list CGS) {
  // Basering is @R.
  if (size(CGS) == 0) {
    if (defined(debug_mode) && debug_mode == 1) {
      fprintf(out, "CGS is empty.");
    }
    return (1);
  }

  if (size(M) == 0) {
    if (defined(debug_mode) && debug_mode == 1) {
      fprintf(out, "M is empty.");
    }
    return (0);
  }

  // Switch to @RP.
  setring @RP;
  def M = imap(@R, M);
  def CGS = imap(@R, CGS);

  int i, j;
  for (i = 1; i <= size(CGS); i++) {
    if (size(CGS[i][3]) > 0) {
      for (j = 1; j <= size(CGS[i][3]); j++) {
	poly f = monic(CGS[i][3][j][1] + CGS[i][3][j][2]);

	if (!listContains(f, M)) {
	  poly pp_f = lppX(CGS[i][3][j][1]);
	  ideal E_cur;
	  list N_cur;
	  (E_cur, N_cur) = makeRRepInBranch(CGS[i][1], CGS[i][2]);
	  list G_branch = CGS[i][3];
	  int is_essential;
	  list DontCare;
	  (is_essential, DontCare) = checkEssentialInBranch(f, pp_f, M, E_cur, N_cur, G_branch, DontCare);
	  if (is_essential) {
	    return (0);
	  }
	}
      } // End for.
    }
  } // End for.

  return (1);
}

/*
proc check_comprehensive(list G, list M, list modcgs, string diff_basis, link out) {
  // Basering is @R.
  if (size(G) == 0) {
    if (defined(debug_mode) && debug_mode == 1) {
      fprintf(out, "G is empty.");
    }
    return (1);
  }

  if (size(M) == 0) {
    if (defined(debug_mode) && debug_mode == 1) {
      fprintf(out, "M is empty.");
    }
    return (0);
  }

  // General case:
  list check_list = list_diff(G, M);
  if (size(check_list) == 0) {
    if (defined(debug_mode) && debug_mode == 1) {
      fprintf(out, "G = M.");
    }
    return (1);
  } else {
    int i, j;
    // Switch to R[X, U].
    setring(@RP);
    def G = imap(@R, G);
    def M = imap(@R, M);
    def modcgs = imap(@R, modcgs);
    def check_list = imap(@R, check_list);

    if (defined(debug_mode) && debug_mode == 1) {    
      fprintf(out, diff_basis);
      show_list_to_file(check_list, out);
      fprintf(out, "].");
    }
    
    for (i = 1; i <= size(check_list); i++) {
      if (defined(debug_mode) && debug_mode == 1) {      
	fprintf(out, newline + "++++++++++++++++++++++++++++");
	fprintf(out, "Now consider g = %s:", string(check_list[i]));
      }
      poly g_tobechecked = check_list[i];
      int is_essential;
      list BL;
      (is_essential, BL) = checkEssential(g_tobechecked, M, modcgs);
      if (is_essential) {
	// g_tobechecked cannot be covered by any poly in M in some branch.
	// Switch back to R[U][X].
	setring(@R);
	// For dumping.
	if (defined(debug_mode)  && debug_mode >= 1) {
	  fprintf(out, "Thus, g is essential for some branch it appears in.");
	}
	return (0);
      } else {
	if (defined(debug_mode) && debug_mode >= 1){
	  fprintf(out, "Thus, g is covered by some poly in M in all branches it appears in.");
	}
      }
    } // Endfor.

    // All polys in check_list is non-essential.
    // Switch back to R[U][X].
    setring(@R);
    return (1);
  } // Endif.
}
*/

proc check_minimal(list M, list CGS) {
  if (size(CGS) == 0) {
    if (defined(debug_mode) && debug_mode == 1) {
      fprintf(out, "CGS is empty.");
    }
    return (1);
  }

  if (size(M) == 0) {
    if (defined(debug_mode) && debug_mode == 1) {
      fprintf(out, "G is empty.");
    }
    return (0);
  }

  list M_subs = gen_sub_list(M);

  int i, j;
  for (i = 1; i <= size(M_subs); i++) {
    // For each maximal proper subset of M.
    if (defined(debug_mode) && debug_mode == 1) {
      fprintf(out, newline + "$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$");
      fprintf(out, "%s. Now check M_sub[%s] = [", string(i), string(i));
      show_list_to_file(M_subs[i], out);
      fprintf(out, "    ]:");
    }

    if (check_comprehensive(M_subs[i], CGS)) {
      if (defined(debug_mode) && debug_mode == 1) {
	fprintf(out, "The subset M_sub[%s] is also a CGS of <F>.", string(i));
      }
      return (0);
    } else {
      if (defined(debug_mode) && debug_mode == 1) {
	fprintf(out, "The subset M_sub[%s] is not comprehensive.", string(i));
      }
    }
  } // End for.
  return (1);
}
/*
proc check_minimal(list M, list modcgs, link out) 
"
Assume that M is already a CGB.
"
{
  if (size(M) <= 1) {
    return (1);
  }

  list M_subs = gen_sub_list(M);

  int i, j;
  for (i = 1; i <= size(M_subs); i++) {
    // For each maximal proper subset of M.
    if (defined(debug_mode) && debug_mode == 1) {
      fprintf(out, newline + "$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$");
      fprintf(out, "%s. Now check M_sub[%s] = [", string(i), string(i));
      show_list_to_file(M_subs[i], out);
      fprintf(out, "    ]:");
    }

    string diff_basis = "M - M_sub[" + string(i) + "] = [";

    if (check_comprehensive(M, M_subs[i], modcgs, diff_basis, out)) {
      // M_sub[i] is also a CGB, then M is not minimal.
      if (defined(debug_mode) && debug_mode == 1) {
	fprintf(out, "The subset M_sub[%s] is also a CGB of <F>.", string(i));
      }
      return (0);
    } else {
      if (defined(debug_mode) && debug_mode == 1) {
	fprintf(out, "The subset M_sub[%s] is not comprehensive.", string(i));
      }
    }
  }
  return (1);
}
*/

proc check_validity(list M, list CGS) {
  // Basering is @RP.
  if (defined(debug_mode) && debug_mode == 1) {
    fprintf(out, newline + "============================");
    fprintf(out, "Now check whether M is comprehensive and minimal:");
    fprintf(out, "------------------");

    fprintf(out, "First, check the comprehensiveness of M:" + newline);
  }

  if (check_comprehensive(M, CGS)) {
    // M is comprehensive, then check the minimality.
    if (defined(debug_mode) && debug_mode == 1) {
      fprintf(out, newline + "M is comprehensive.");
      fprintf(out, newline + newline + "================================");
      fprintf(out, "Second, check the minimality of M:");
    }
    if (check_minimal(M, CGS)) {
      // M is also minimal.
      if (defined(debug_mode) && debug_mode == 1) {
	fprintf(out, newline + "M is minimal.");
      }
      fprintf(out, "It is comprehensive and minimal.");
      return (1);
    } else {
      // M is not minimal.
      if (defined(debug_mode) && debug_mode == 1) {
	fprintf(out, newline + "M is not minimal.");
      }
      fprintf(out, "It is comprehensive, but not minimal.");
      return (0);
    }
  } else {
    // M is not comprehensive.
    if (defined(debug_mode) && debug_mode == 1) {
      fprintf(out, newline + "M is not comprehensive.");
    }
    fprintf(out, "It is not comprehensive.");
    return (0);
  }
}

/*
proc check_validity(ideal cgb, list mccgb, list modcgs, list modcgs_new, link out) {
  if (defined(debug_mode) && debug_mode == 1) {
    fprintf(out, newline + "============================");
    fprintf(out, "Now check whether M is comprehensive and minimal:");
    fprintf(out, "------------------");

    fprintf(out, "First, check the comprehensiveness of M:" + newline);
  }

  list G;
  int i;
  if (size(cgb) > 0) {
    for (i = 1; i <= size(cgb); i++) {
      G = insert(G, cgb[i], size(G));
    }
  }

  string diff_basis = "G - M = [";

  if (check_comprehensive(G, mccgb, modcgs, diff_basis, out)) {
    // mccgb is comprehensive, then check the minimality.
    if (defined(debug_mode) && debug_mode == 1) {
      fprintf(out, newline + "M is comprehensive.");
      fprintf(out, newline + newline + "================================");
      fprintf(out, "Second, check the minimality of M:");
    }
    if (check_minimal(mccgb, modcgs_new, out)) {
      // mccgb is also minimal.
      if (defined(debug_mode) && debug_mode == 1) {
	fprintf(out, newline + "M is minimal.");
      }
      return ("", 1);
    } else {
      // mccgb is not minimal.
      if (defined(debug_mode) && debug_mode == 1) {
	fprintf(out, newline + "M is not minimal.");
      }
      return ("it is not minimal", 0);
    }
  } else {
    //mccgb is not comprehensive.
    if (defined(debug_mode) && debug_mode == 1) {
      fprintf(out, newline + "M is not comprehensive.");
    }
    return ("it is not comprehensive", 0);
  }
}
*/
