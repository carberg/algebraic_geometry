LIB "mcgb.lib";
LIB "mcgbcheck.lib";
LIB "buchtrace.lib";

proc simulate(ideal E, list N, ideal F, int sim_times, link out, int debug_mode, intvec sim_option) {
  def BR = basering;
  system("--no-warn", 1);

  exportto(Top, out);
  exportto(Top, debug_mode);
  link special_out = "debug_info.mp";
  exportto(Top, special_out);
  open(out);
  open(special_out);


  int gen_simpl_flag = 1;
  
  int i, j;

  // Print the ring configuration.
  fprintf(out, "The given ring is:");
  fprintf(out, "%s" + newline, BR);

  // Print the given parametric ideal.
  fprintf(out, "F = {");
  if (size(F) > 0) {
    for (i = 1; i < size(F); i++) {
      fprintf(out, "%s, ", F[i]);
    }
    fprintf(out, "%s" + newline + "}." + newline, F[size(F)]);
  } else {
    fprintf(out, newline + "}." + newline);
  }

  // Print the given parameter space.
  fprintf(out, "E = {%s}." + newline, E);
  fprintf(out, "N = {%s}." + newline, string(N));

  // KSWCGB and KSWCGS.

  ideal G_beginning;
  list Modcgs;

  (G_beginning, Modcgs) = cgb_mod(F, E, N, out);
  printf("Step 0 is finished!");
  list all_polys = idealToList(G_beginning);

  set_global_rings_mcgb();
  G_beginning = purifyCGB(G_beginning);
  exportto(Top, G_beginning);
  exportto(Top, Modcgs);

  ideal MCGB_new;
  list cgs_mcgb_new;
  
  (MCGB_new, cgs_mcgb_new) = getMCGBNew1(E, listToIdeal(N), F);
  all_polys = mergeList(all_polys, idealToList(MCGB_new));
  printf("Step one finished!");

  ideal MCGB;
  list cgs_mcgb;
  (MCGB, cgs_mcgb) = getMCGB(E, listToIdeal(N), F);
  all_polys = mergeList(all_polys, idealToList(MCGB));
  
  
  ideal RGB = getRGB(F);
  all_polys = mergeList(all_polys, idealToList(RGB));

  ideal G_comp = mcgbGenerate(E, N, RGB, 0);
  G_comp = sortSetAsce(G_comp);
  all_polys = mergeList(all_polys, idealToList(G_comp));

  all_polys = sortSetAsce(all_polys);
  exportto(Top, all_polys);

  
  fprintf(out, "---------------------------" + newline);
  fprintf(out, "MCGB" + newline);
  showCCGB(MCGB, all_polys, out);
  fprintf(out, "Size is: %s." + newline, string(size(MCGB)));
  check_validity(idealToList(MCGB), Modcgs);
  
  fprintf(out, "--------------------------" + newline);
  fprintf(out, "MCGB_new" + newline);
  showCCGB(MCGB_new, all_polys, out);
  fprintf(out, "Size is: %s." + newline, string(size(MCGB_new)));
  check_validity(idealToList(MCGB_new), Modcgs);

  
  int cmp_flag = lessSet(idealToList(MCGB_new), idealToList(MCGB));
  if (cmp_flag == 1) {
    fprintf(out, "Better than MCGB!");
    printf("Better than MCGB!");
  } else {
    if (cmp_flag == 2) {
      fprintf(out, "Same as MCGB!");
      printf("Same as MCGB!");
    } else {
      fprintf(out, "Worse than MCGB!");
      printf("Worse than MCGB!");
    }
  }

  fprintf(out, "-----------Completion----------" + newline);
  fprintf(out, "Starting from RGB, G_comp = ");
  showCCGB(G_comp, all_polys, out);
  check_validity(idealToList(G_comp), Modcgs);

  
  fprintf(out, "--------------------------" + newline);
  fprintf(out, "RGB" + newline);
  showCCGB(RGB, all_polys, out);
  fprintf(out, "Size is: %s." + newline, string(size(RGB)));
  check_validity(idealToList(RGB), Modcgs);
  
  fprintf(out, "==================================" + newline);
  fprintf(out, "%s" + newline, StringCGB(G_beginning, all_polys));
  fprintf(out, newline + "Size is: %s." + newline, string(size(G_beginning)));
  
  fprintf(out, "--------------------------------------" + newline);
  fprintf(out, "%s" + newline, StringModCGS_mod(F, Modcgs, 1));
    

  
  /*      
  
  if (!checkCGBness(G_beginning)) {
    printf("G_beginning is not a CGB!");
  } else {
    fprintf(out, "G_beginning is a CGB!");
  }

  printf("CGBness checking finished!");
  */
  /*
    ideal CCGB;
    list CGS_ccgb;
    (CCGB, CGS_ccgb) = ccgbMain(E, N, F);
    
    list all_polys = idealToList(RGB);
  

    // Show CCGB.
    fprintf(out, newline + "------------------------------" + newline);
    showCCGB(CCGB, all_polys, out);
    fprintf(out, newline + "Size is: %s." + newline, string(size(CCGB)));
    if (size(CCGB) > 0) {
      check_validity(idealToList(CCGB), Modcgs);
    } else {
      check_validity(list(), Modcgs);
    }
  
  ideal G_min = mcgbGenerate(E, N, CCGB);
  G_min = sortSetAsce(G_min);
  fprintf(out, "G_min = [");
  int i;
  for (i = 1; i <= size(G_min); i++) {
    fprintf(out, "    %s,", G_min[i]);
  }
  fprintf(out, "].");
  check_validity(idealToList(G_min), Modcgs);

  if (idealEquals(G_min, CCGB)) {
    printf("Both are equal.");
    fprintf(out, "Both are equal.");
  } else {
    printf("Different from CCGB!");
    fprintf(out, "Different from CCGB!");
  }
  
  // Generate RGB.
  /*
  ideal RGB = getRGB(F);
  
  if (!checkCGBness(RGB)) {
    printf("RGB is not a CGB!");
  }
  */

  // Generate MCGBs.
  /*
  int sim_cnt = 1;
  list M_list;
  list M_split_list;
  list M_split_norm_list;

  while (sim_cnt <= sim_times) {
    //    list M, M_split, M_split_norm, Modcgs_new;
    list M, Modcgs_new;
    (M, Modcgs_new) = mcgbRandMain(E, N, F);
    if (size(M_list) == 0 || !listContainsList(M_list, M)) {
      M = sortSetAsce(M);
      M_list = insert(M_list, M, size(M_list));

      //      M_split = splitCGB(M, RGB, splitCriterion);
      //      M_split_list = insert(M_split_list, M_split, size(M_split_list));

      //      list Modcgs_split = buildCGS(M_split);
      //      M_split_norm = makeCGBReduced(M_split, Modcgs_split);
      //      M_split_norm = sortSetAsce(M_split_norm);
      //      M_split_norm_list = insert(M_split_norm_list, M_split_norm, size(M_split_norm_list));
    }
    sim_cnt = sim_cnt + 1;
  }
  
  // Generate CCGB.
  /*
  ideal CCGB;
  list CGS_ccgb;
  (CCGB, CGS_ccgb) = ccgbMain(E, N, F);

  
  if (!checkCGBness(CCGB)) {
    printf("CCGB is not a CGB!");
  }
  */
  // Sort polynomials in KSWCGB, RGB, MCGBs, and CCGB w.r.t. the ordering.
  
  //list all_polys = idealToList(CCGB);
  
  /*
  // Add polys in RGB to all_polys.
  if (size(RGB) > 0) {
    for (i = 1; i <= size(RGB); i++) {
      if (!listContains(all_polys, RGB[i])) {
	all_polys = insert(all_polys, RGB[i], size(all_polys));
      }
    }
  }
  */
  /*
  // Add polys in KSWCGB to all_polys;
  if (size(G_beginning) > 0) {
    for (i = 1; i <= size(G_beginning); i++) {
      if (!listContains(all_polys, G_beginning[i])) {
	all_polys = insert(all_polys, G_beginning[i], size(all_polys));
      }
    }
  }
  
  // Add polys in MCGBs to all_polys.
  if (size(M_list) > 0) {
    for (i = 1; i <= size(M_list); i++) {
      if (size(M_list[i]) > 0) {
	for (j = 1; j <= size(M_list[i]); j++) {
	  if (!listContains(all_polys, M_list[i][j])) {
	    all_polys = insert(all_polys, M_list[i][j], size(all_polys));
	  }
	}
      }
    }
  }

  // Add polys in M_split_list to all_polys.
  /*
  if (size(M_split_list) > 0) {
    for (i = 1; i <= size(M_split_list); i++) {
      if (size(M_split_list[i]) > 0) {
	for (j = 1; j <= size(M_split_list[i]); j++) {
	  if (!listContains(all_polys, M_split_list[i][j])) {
	    all_polys = insert(all_polys, M_split_list[i][j], size(all_polys));
	  }
	}
      }
    }
  }

  // Add polys in MCGBs after splitting and reduction to all_polys.
  if (size(M_split_norm_list) > 0) {
    for (i = 1; i <= size(M_split_norm_list); i++) {
      if (size(M_split_norm_list[i]) > 0) {
	for (j = 1; j <= size(M_split_norm_list[i]); j++) {
	  if (!listContains(all_polys, M_split_norm_list[i][j])) {
	    all_polys = insert(all_polys, M_split_norm_list[i][j], size(all_polys));
	  }
	}
      }
    }
  }
  
  all_polys = sortSetAsce(all_polys);
  exportto(Top, all_polys);
  
  // Print RGB and/or CCGB.
  /*
  fprintf(out, "=============================" + newline);
  if (idealEquals(CCGB, RGB)) {
    // RGB is the CCGB.
    fprintf(out, newline + "RGB is the CCGB." + newline);
    fprintf(out, "----------------------------" + newline);
    showCCGB(CCGB, all_polys, out);
    fprintf(out, "Size is: %s." + newline, string(size(CCGB)));
    if (size(CCGB) != 0) {
      check_validity(idealToList(CCGB), Modcgs);
    } else {
      check_validity(list(), Modcgs);
    }

  } else {
    // RGB is not the CCGB.

    // Show RGB.
    fprintf(out, newline + "RGB is not the CCGB." + newline);
    fprintf(out, "--------------------------------" + newline);
    showRGB(RGB, all_polys, out);
    fprintf(out, newline + "Size is : %s." + newline, string(size(RGB)));
    if (size(RGB) != 0) {
      check_validity(idealToList(RGB), Modcgs);
    } else {
      check_validity(list(), Modcgs);
    }
  
    // Show CCGB.
    fprintf(out, newline + "------------------------------" + newline);
    showCCGB(CCGB, all_polys, out);
    fprintf(out, newline + "Size is: %s." + newline, string(size(CCGB)));
    if (size(CCGB) > 0) {
      check_validity(idealToList(CCGB), Modcgs);
    } else {
      check_validity(list(), Modcgs);
    }
    
  }
  */
  // Print MCGBs.
  /*
  if (size(M_list) > 1) {
    (M_list, M_split_norm_list) = sortMCGBs(M_list, M_split_norm_list);
  }
  */
  /*
  if (size(M_list) > 0) {
    for (i = 1; i <= size(M_list); i++) {
      fprintf(out, "--------------------------" + newline);
      fprintf(out, "M_%s" + newline, string(i));
      showMCGB(M_list[i], all_polys, out);
      fprintf(out, "Size is: %s." + newline, string(size(M_list[i])));
      check_validity(M_list[i], Modcgs);
      G_min = mcgbGenerate(E, N, listToIdeal(M_list[i]));
      G_min = sortSetAsce(G_min);
      fprintf(out, "G_min = [");
      int i;
      for (i = 1; i <= size(G_min); i++) {
	fprintf(out, "    %s,", G_min[i]);
      }
      fprintf(out, "].");
      check_validity(idealToList(G_min), Modcgs);
    }
  }
  */
  // Print the KSWCGS and KSWCGB.
  

  
  
  close(out);
  close(special_out);
  
}
