LIB "mcgb.lib";
LIB "mcgbcheck.lib";
LIB "completion.lib";
LIB "buchtrace.lib";

proc simulate(ideal E, list N, ideal F, int sim_times, link out, int debug_mode) {
  def BR = basering;
  system("--no-warn", 1);
  system("--ticks-per-sec", 1000);

  exportto(Top, out);
  exportto(Top, debug_mode);
  link special_out = "debug_info.mp";
  link time_res = "time_info.mp";
  exportto(Top, special_out);
  open(out);
  open(special_out);
  open(time_res);


  int gen_simpl_flag = 1;
  
  int i, j;

  // Print the ring configuration.
  fprintf(out, "The given ring is:");
  fprintf(out, "%s" + newline, BR);

  fprintf(time_res, newline + "+++++++++++++++++++++");
  fprintf(time_res, "The given ring is:");
  fprintf(time_res, "%s"+newline, BR);

  // Print the given parametric ideal.
  fprintf(out, "F = {");
  if (size(F) > 0) {
    for (i = 1; i < size(F); i++) {
      fprintf(out, "%s, ", F[i]);
    }
    fprintf(out, "%s" + newline + "}." + newline, F[size(F)]);
  } else {
    fprintf(out, newline + "}." + newline);
  }

  // Print the given parameter space.
  fprintf(out, "E = {%s}." + newline, E);
  fprintf(out, "N = {%s}." + newline, string(N));

  // KSWCGB and KSWCGS.

  set_global_rings_mcgb();
  

  
  set_global_rings();
  
  
  ideal G_origin;
  list Modcgs;
  timer = 0;
  int cnt_Time = timer;
  (G_origin, Modcgs) = cgb_mod(F, E, N, 1, out);
  int time_cnt_KSW = timer - cnt_Time;
  fprintf(time_res, "|CGS| = %s.", string(size(Modcgs)));
  fprintf(time_res, "|G| = %s.", string(size(G_origin)));
  fprintf(time_res, "Time Used: %s ms." + newline, string(time_cnt_KSW));

  
  G_origin = sortSetAsce(G_origin);
  printf("Step 0 is finished!");
  list all_polys = idealToList(G_origin);
  
  set_global_rings_mcgb();
  ideal G_init = purifyCGB(G_origin);
  G_init = sortSetAsce(G_init);
  all_polys = mergeList(all_polys, idealToList(G_init));
  exportto(Top, G_init);
  exportto(Top, Modcgs);
  
  ideal M1;
  list cgs_m1;
  timer = 0;
  cnt_Time = timer;
  (M1, cgs_m1) = mcgbMainComp(G_init, Modcgs);
  int time_cnt_MCGB = timer - cnt_Time;
  fprintf(time_res, "|CGS_M| = %s.", string(size(cgs_m1)));
  fprintf(time_res, "|M|: %s", string(size(M1)));
  fprintf(time_res, "Time Used: %s ms." + newline, string(time_cnt_MCGB));
  all_polys = mergeList(all_polys, idealToList(M1));
  
  ideal M2;
  list cgs_m2;
  timer = 0;
  cnt_Time = timer;
  (M2, cgs_m2) = getMCGBComp(E, listToIdeal(N), G_init, Modcgs);
  int time_cnt_MSIMPL = timer - cnt_Time;
  fprintf(time_res, "|CGS_M_SIMPL| = %s.", string(size(cgs_m2)));
  fprintf(time_res, "|M_simpl| = %s.", string(size(M2)));
  fprintf(time_res, "Time Used: %s ms." + newline, string(time_cnt_MSIMPL));
  all_polys = mergeList(all_polys, idealToList(M2));

  fprintf(time_res, "Total time of MCGB: %s ms;", string(time_cnt_MCGB+time_cnt_KSW));
  fprintf(time_res, "Percentage of MCGB: %s / %s.", string(time_cnt_MCGB), string(time_cnt_MCGB + time_cnt_KSW));
  fprintf(time_res, "Total time of M_simpl: %s ms;", string(time_cnt_MSIMPL + time_cnt_KSW));
fprintf(time_res, "Percentage of M_simpl: %s / %s.", string(time_cnt_MSIMPL), string(time_cnt_MSIMPL + time_cnt_KSW));
 
  ideal MCGB_step;
  list cgs_step;
  (MCGB_step, cgs_step) = getMCGBNew1(E, listToIdeal(N), F, 1);
  all_polys = mergeList(all_polys, idealToList(MCGB_step));
  
  /*
  ideal G_comp = mcgbGenerate(E, N, RGB, 0);
  G_comp = sortSetAsce(G_comp);
  all_polys = mergeList(all_polys, idealToList(G_comp));
  */
  
  all_polys = sortSetAsce(all_polys);
  exportto(Top, all_polys);

  if (size(cgs_m1) > size(Modcgs)) {
    printf("Have branch split!");
  } else {
    printf("No branch split!");
  }

  int cmp_flag = lessSet(idealToList(M2), idealToList(M1));
  if (cmp_flag == 1) {
    fprintf(out, "M2 is better than M1!");
    printf("M2 is Better than M1!");
  } else {
    if (cmp_flag == 2) {
      fprintf(out, "M2 is the same as M1!");
      printf("M2 is the same as M1!");
    } else {
      fprintf(out, "M2 is worse than M1!");
      printf("M2 is worse than M1!");
    }
  }

  cmp_flag = lessSet(idealToList(MCGB_step), idealToList(M2));
  if (cmp_flag == 1) {
    fprintf(out, "MCGB_step is better than M2");
    printf("MCGB_step is better than M2!");
  } else {
    if (cmp_flag == 2) {
      fprintf(out, "MCGB_step is the same as M2!");
      printf("MCGB_step is the same as M2!");
    } else {
      fprintf(out, "MCGB_step is worse than M2!");
      printf("MCGB_step is worse than M2!");
    }
  }
  

  fprintf(out, "---------------------------" + newline);
  fprintf(out, "M1" + newline);
  showCCGB(M1, all_polys, out);
  fprintf(out, "Size is: %s." + newline, string(size(M1)));
  check_validity(idealToList(M1), Modcgs);

  fprintf(out, "---------------------------" + newline);
  fprintf(out, "M2" + newline);
  showCCGB(M2, all_polys, out);
  fprintf(out, "Size is: %s." + newline, string(size(M2)));
  check_validity(idealToList(M2), Modcgs);

  
  fprintf(out, "---------------------------" + newline);
  fprintf(out, "MCGB_step" + newline);
  showCCGB(MCGB_step, all_polys, out);
  fprintf(out, "Size is: %s." + newline, string(size(MCGB_step)));
  check_validity(idealToList(MCGB_step), Modcgs);

  fprintf(out, "=============Faith=================" + newline);
  fprintf(out, "Before preprocess:");
  fprintf(out, "%s" + newline, StringCGB(G_origin, all_polys));
  fprintf(out, newline + "Size is: %s." + newline, string(size(G_origin)));

  fprintf(out, "After preprocess:");
  fprintf(out, "%s" + newline, StringCGB(G_init, all_polys));
  fprintf(out, newline + "Size is: %s." + newline, string(size(G_init)));
  check_validity(idealToList(G_init), Modcgs);
  
  fprintf(out, "--------------------------------------" + newline);
  fprintf(out, "%s" + newline, StringModCGS_mod(F, Modcgs, 1));
  
  /*
  for (i = 1; i <= size(MCGB_new); i++) {
    if (!idealContains(G_beginning, MCGB_new[i])) {
      fprintf(out, "MCGB is not a subset of KSWCGB!");
      printf("MCGB is not a subset of KSWCGB!");
      break;
    }
  }
  */
  
  /*
  fprintf(out, "-----------Completion----------" + newline);
  fprintf(out, "Starting from RGB, G_comp = ");
  showCCGB(G_comp, all_polys, out);
  check_validity(idealToList(G_comp), Modcgs);
  */
  
  
  
  
  close(out);
  close(special_out);
  close(time_res);
}
